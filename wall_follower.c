#pragma config(Sensor, S1,     leftSonar,           sensorSONAR)
#pragma config(Sensor, S2,     centreSonar,         sensorSONAR)
#pragma config(Sensor, S3,     rightSonar,          sensorSONAR)
#pragma config(Motor,  motorB,          leftMotor,     tmotorNormal, PIDControl, )
#pragma config(Motor,  motorC,          rightMotor,    tmotorNormal, PIDControl, )
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

///wall follower

int desiredDistance = 30;
int leftMotorSpeed  = 0;
int rightMotorSpeed  = 0;
int previousLeftSonar = 0;
int previousRightSonar = 0;
int leftErr = 0;
int rightErr = 0;
int centreSonarValue = 0;
int leftSonarValue = 0;
float kControl = 0.9;
int desiredSpeed = 30;

void doTurn()
{
//part of the testing reigme of the local cells
	//decided that anticlockwise is positive
	float rightSonarValue = SensorValue(rightSonar); //obvious
  float leftSonarValue = SensorValue(leftSonar);
  float centreSonarValue = SensorValue(centreSonar);
  nSyncedMotors = synchBC;

	if(centreSonarValue<=20)
	{
	 // if(leftSonarValue > 19 && rightSonarValue < 19)
	  //{
/*
	  	nSyncedTurnRatio = 100;
	  	nMotorEncoderTarget[motorB] = 190;
	    motor[motorB] = -50;
	    while(nMotorRunState[motorB] != runStateIdle) {}
	    nSyncedTurnRatio = -100;
	  	nMotorEncoderTarget[motorB] = 190;
	    motor[motorB] = -50;
	    while(nMotorRunState[motorB] != runStateIdle) {}
*/
	 // }
		//else if(leftSonarValue < 19 && rightSonarValue > 19)
	 // {
	  	//nSyncedTurnRatio = 100;
	  	//nMotorEncoderTarget[motorB] = 220;
	    //motor[motorB] = -50;
	    //while(nMotorRunState[motorB] != runStateIdle) {}
	    nSyncedTurnRatio = -100;
	  	nMotorEncoderTarget[motorB] = 220;
	    motor[motorB] = 50;
	    while(nMotorRunState[motorB] != runStateIdle) {}

	  //}
	/*	else if(leftSonarValue < 19 && rightSonarValue < 19)
	  {
	  	nSyncedTurnRatio = 100;
	  	nMotorEncoderTarget[motorB] = 190;
	    motor[motorB] = -50;
	    while(nMotorRunState[motorB] != runStateIdle) {}
	    nSyncedTurnRatio = -100;
	  	nMotorEncoderTarget[motorB] = 370;
	    motor[motorB] = 50;`
	    while(nMotorRunState[motorB] != runStateIdle) {}

	   }
	  else
	  {
	  	nSyncedTurnRatio = 100;
	  	nMotorEncoderTarget[motorB] = 190;
	    motor[motorB] = -50;
	    while(nMotorRunState[motorB] != runStateIdle) {}
	  	nSyncedTurnRatio = -100;
	  	nMotorEncoderTarget[motorB] = 190;
	    motor[motorB] = -50;
	    while(nMotorRunState[motorB] != runStateIdle) {}

	  }*/
  }
  nSyncedMotors = synchNone;
}


task main()
{
  nMotorPIDSpeedCtrl[leftMotor] = mtrEncoderReg;
  nMotorPIDSpeedCtrl[rightMotor] = mtrEncoderReg;
  centreSonarValue = SensorValue[centreSonar];
  while(1)
  {
  	//nMotorEncoderTarget[leftMotor] =  400;
  	//nMotorEncoderTarget[rightMotor] = 400;
    motor[leftMotor] = desiredSpeed;
    motor[rightMotor] = desiredSpeed;
    while((nMotorRunState[leftMotor] != runStateIdle) || (nMotorRunState[rightMotor] != runStateIdle))
    {
    	centreSonarValue = SensorValue[centreSonar];
    	leftSonarValue = SensorValue[leftSonar];
    	leftErr = desiredDistance - leftSonarValue;
    	//saturate
      if(leftErr>40) {leftErr = 40;}
    	if(leftErr<-40) {leftErr = -40;}
      eraseDisplay();
      nxtDisplayCenteredBigTextLine(1,"%3d",leftSonarValue);
      nxtDisplayCenteredBigTextLine(3,"%3d",leftErr);

      if(leftErr>1)
      {
    	  motor[leftMotor] = desiredSpeed;
    	  motor[rightMotor] = desiredSpeed-(int)(kControl*leftErr);
    	  wait10Msec(5);
    	  motor[leftMotor] = desiredSpeed;
    	  motor[rightMotor] = desiredSpeed+(int)(kControl*leftErr);

      }
      else if(leftErr<-1)
      {
        motor[leftMotor] = desiredSpeed+(int)(kControl*leftErr);
    	  motor[rightMotor] = desiredSpeed;
    	  wait10Msec(5);
    	  motor[leftMotor] = desiredSpeed-(int)(kControl*leftErr);
    	  motor[rightMotor] = desiredSpeed;

      }
      else
      {
      	motor[leftMotor] = desiredSpeed;
        motor[rightMotor] = desiredSpeed;
      }

      centreSonarValue = SensorValue[centreSonar];
      if(centreSonarValue <= 20) {break;}
    }
    //motor[leftMotor] = 0;
    //motor[rightMotor] = 0;
    doTurn();
  }
}

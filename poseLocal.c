#pragma config(Sensor, S1,     leftSonar,           sensorSONAR)
#pragma config(Sensor, S2,     centreSonar,         sensorSONAR)
#pragma config(Sensor, S3,     rightSonar,          sensorSONAR)
#pragma config(Motor,  motorB,          leftMotor,            tmotorNxtEncoderClosedLoop)
#pragma config(Motor,  motorC,          rightMotor,           tmotorNxtEncoderClosedLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//      Title:- Pose Cells
//      Author:- Lachlan Smith (RobotC)
//               Mark Wakabayashi (Jave version)
//               Michael Milford (original algorithim/c code)
//      Purpose:- This is implementing pose cells and local cell together
//
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
|
| each full rotation of the wheel is 360 encoders clicks and 18cm (0.18m)
|
| Still pondering whether to have an array holding just active cells or to search the entire pose structure
|
| just discovered while u cant pass array u can pass structures holding array

typedef struct
{
	float number[2];
} test;

void testprogram(test &tester)
{
  tester.number[0] = 1;
  tester.number[1] = 2;
}

task main()
{
  test laugh;
	testprogram(laugh);
	nxtDisplayCenteredTextLine(1, "%f", laugh.number[0]);
  nxtDisplayCenteredTextLine(2, "%f", laugh.number[1]);
	wait10Msec(200);
}

| the above works - so need to write code to take advantage of this
|
|


*/

//----include files----//
#include "poseCell.h";
#include "localNeural.h";

//----General In-Module Variables----//
int numActive = 0; //number of active cells
int currentTheta = 0; //theta for pose and turns
char currentDirection = 0; //direction for pose and turns
float localTemp[numNeuralUnits]; //holds the temporary neural value
float localComparison[numNeuralUnits]; //what the local cell data is loaded into
float rightSonarValue = 0; //obvious
float leftSonarValue = 0;
float centreSonarValue = 0;
char nextEmptyCell = 0; //used for holding the next empty cell in the localcell Struct
float tempCalcC = 0;
float tempCalcL = 0;
float tempCalcR = 0;

//                           //
//----Pose Cell Functions----//
//                           //

//----initialises the start cell and sets starting activation----//
void startCell()
{
  poseWorld.maxActivatedCell.x = 5;
  poseWorld.maxActivatedCell.y = 5;
  poseWorld.maxActivatedCell.theta = 0;
  poseWorld.poseActivity[5].array2D[5][0] = startActivation;
}

//----initalises all pose cells as inactive and sets all pose activity to zero----//
void setupPoseStructure()
{
	//initialises loop variables
  char i;
  char j;
  char k;

  for(i = 0; i < sizeX; i++)
  {
    for(j = 0; j < sizeY; j++)
    {
      for(k = 0; k < sizeTheta; k++)
      {
        poseWorld.poseActivity[i].array2D[j][k] = 0; //no activity
        tempPose[i].array2D[j][k] = 0;
      }
    }
  }
}

//----Excitation matrix----//
void excitationMatrixSetup()
{
	//done in matlab - probably should check if right
  excitation_Weights[0].array2D[0][0] =  0.0495;
  excitation_Weights[0].array2D[0][1] =  0.3655;
  excitation_Weights[0].array2D[0][2] =  0.0495;
  excitation_Weights[0].array2D[1][0] =  0.1727;
  excitation_Weights[0].array2D[1][1] =  1.2757;
  excitation_Weights[0].array2D[1][2] =  0.1727;
  excitation_Weights[0].array2D[2][0] =  0.0495;
  excitation_Weights[0].array2D[2][1] =  0.3655;
  excitation_Weights[0].array2D[2][2] =  0.0495;

  excitation_Weights[1].array2D[0][0] =  0.1727;
  excitation_Weights[1].array2D[0][1] =  1.2757;
  excitation_Weights[1].array2D[0][2] =  0.1727;
  excitation_Weights[1].array2D[1][0] =  0.6026;
  excitation_Weights[1].array2D[1][1] =  4.4528;
  excitation_Weights[1].array2D[1][2] =  0.6026;
  excitation_Weights[1].array2D[2][0] =  0.1727;
  excitation_Weights[1].array2D[2][1] =  1.2757;
  excitation_Weights[1].array2D[2][2] =  0.1727;

  excitation_Weights[2].array2D[0][0] =  0.0495;
  excitation_Weights[2].array2D[0][1] =  0.3655;
  excitation_Weights[2].array2D[0][2] =  0.0495;
  excitation_Weights[2].array2D[1][0] =  0.1727;
  excitation_Weights[2].array2D[1][1] =  1.2757;
  excitation_Weights[2].array2D[1][2] =  0.1727;
  excitation_Weights[2].array2D[2][0] =  0.0495;
  excitation_Weights[2].array2D[2][1] =  0.3655;
  excitation_Weights[2].array2D[2][2] =  0.0495;
}

//----Wrapping values in x-direction in Pose structure----//
char getWrappedX(char indexX)
{
  if(indexX < 0)
  {
    return (indexX + sizeX);
  }
  else if(indexX >= sizeX)
  {
    return (indexX - sizeX);
  }
  return indexX;
}

//----Wrapping values in y-direction in Pose structure----//
char getWrappedY(char indexY)
{
  if(indexY < 0)
  {
    return (indexY + sizeY);
  }
  else if(indexY >= sizeY)
  {
    return (indexY - sizeY);
  }
  return indexY;
}

//----Wrapping values in theta-direction in Pose structure----//
char getWrappedTheta(char indexTheta)
{
  if(indexTheta < 0)
  {
    return (indexTheta + sizeTheta);
  }
  else if(indexTheta >= sizeTheta)
  {
    return (indexTheta - sizeTheta);
  }
  return indexTheta;
}

//----Sets activation in cell and handles maximum cell----//
void setActivation(char cellX, char cellY, char cellTheta, float activation)
{
	float previousActivation; //previous activation of a cell
	float maxActivation; //activation of max axtivated cell
	char maxX;  //co-ordinates of max activated cell
	char maxY;
	char maxTheta;

	//set values
  previousActivation = poseWorld.poseActivity[cellX].array2D[cellY][cellTheta];
  maxX = poseWorld.maxActivatedCell.x;
  maxY = poseWorld.maxActivatedCell.y;
  maxTheta = poseWorld.maxActivatedCell.theta;
  maxActivation = poseWorld.poseActivity[maxX].array2D[maxY][maxTheta];

  if(previousActivation == activation)
  {//if the same do nothing, exit function
    return;
  }
  poseWorld.poseActivity[cellX].array2D[cellY][cellTheta] = activation; //else set activation

  if(activation > maxActivation)
  {//if activation greater than max, then set as maximum
    poseWorld.maxActivatedCell.x = cellX;
    poseWorld.maxActivatedCell.y = cellY;
    poseWorld.maxActivatedCell.theta = cellTheta;
  }
}

//----fills temp pose structure with current pose activity----//
void fillTempPose()
{
	//loop stuff
	char i;
  char j;
  char k;

	for(i = 0; i < sizeX; i++)
  {
    for(j = 0; j < sizeY; j++)
    {
      for(k = 0; k < sizeTheta; k++)
      {
        tempPose[i].array2D[j][k] = poseWorld.poseActivity[i].array2D[j][k]; //fill tempActivity with poseActivity
       }
    }
  }
}

//----the reverse of above----//
void fillFinalPose()
{
	//loop stuff
	char i;
  char j;
  char k;

	for(i = 0; i < sizeX; i++)
  {
    for(j = 0; j < sizeY; j++)
    {
      for(k = 0; k < sizeTheta; k++)
      {
        poseWorld.poseActivity[i].array2D[j][k] = tempPose[i].array2D[j][k];
      }
    }
  }
}

//----Injects additional activity into cells----//
void injectEnergy (float stepSize, char xCell, char yCell, char thetaCell)
{
  float previousActivation = poseWorld.poseActivity[poseAssoc.xCell].array2D[poseAssoc.yCell][poseAssoc.thetaCell];
  setActivation(poseAssoc.xCell,poseAssoc.yCell,poseAssoc.thetaCell, previousActivation + injectionStrength * stepSize);
}

//----Excites neighbouring cells----//
void doExcitation(float stepSize)
{
  //initialises loop varibles
  char i;
  char j;
  char k;

  char relX;
  char relY;
  char relTheta;

  fillTempPose();

  for(i = 0; i < sizeX; i++)
  {
    for(j = 0; j < sizeY; j++)
    {
      for(k = 0; k < sizeTheta; k++)
      {
        if(poseWorld.poseActivity[i].array2D[j][k] > 0) //if cell active
        {
        	float thisActivation = poseWorld.poseActivity[i].array2D[j][k];
        	for (relX = -influenceXY; relX <= influenceXY; relX++)
        	{
            char neighbourX = getWrappedX(i + relX);
            for(relY = - influenceXY; relY<= influenceXY; relY++)
            {
              char neighbourY = getWrappedY(j + relY);
              for(relTheta = -influenceTheta; relTheta <= influenceTheta; relTheta++)
              {
                char neighbourTheta = getWrappedTheta(k + relTheta);
              	float excitationWeight = excitation_Weights[relX + influenceXY].array2D[relY + influenceXY][relTheta + influenceTheta];
                tempPose[neighbourX].array2D[neighbourY][neighbourTheta] += (thisActivation * excitationWeight * stepSize);
              }
            }
        	}
        }
      }
    }
  }
  fillFinalPose();
}

//----Inhibits neighbouring cells----//
float doInhibition(float stepSize)
{
	float inhibition = globalInhibition * stepSize;
  float activationSum = 0;
  numActive = 0; //clear number of active cells counter

  //initialise loop variable
  char i;
  char j;
  char k;

  for(i = 0; i < sizeX; i++)
  {
    for(j = 0; j < sizeY; j++)
    {
      for(k = 0; k < sizeTheta; k++)
      {
        if(poseWorld.poseActivity[i].array2D[j][k] > 0) //if cell active
        {
        	float activation = poseWorld.poseActivity[i].array2D[j][k] - inhibition;
          if(activation <=0)
          {
            activation = 0; //cant have negative activity
          }
          setActivation(i, j, k, activation); //set activation and see if is maximum
          activationSum += activation;
          if(activation>0)
          {
            numActive++; //increase number of active cells
          }
        }
      }
    }
  }
  return activationSum;
}

//----Normalises the activity in the pose matrix----//
void doNormalisation(float activationSum)
{//requires activationSum from inhibition

  //initalise loop variables
	char i;
  char j;
  char k;

  for(i = 0; i < sizeX; i++)
  {
    for(j = 0; j < sizeY; j++)
    {
      for(k = 0; k < sizeTheta; k++)
      {
        if(poseWorld.poseActivity[i].array2D[j][k] > 0) //if active
        {
        	poseWorld.poseActivity[i].array2D[j][k] = poseWorld.poseActivity[i].array2D[j][k] / activationSum; //normalise
        }
      }
    }
  }
}

//----Sets up the distribution for activity----//
void getActivationDistribution(float offsetX, float offsetY, float offsetTheta)
{
  //initialise variables
  char signX;
  char signY;
  char signTheta;
  float portion;

  char i;
  char j;
  char k;

  signX = -1;
  for(i = 0; i < 2; i++)
  {
    signY = -1;
    for(j = 0; j < 2; j++)
    {
      signTheta = -1;
      for(k = 0; k < 2; k++)
      {
        portion =  ((1-i) + signX * offsetX) * ((1-j) + signY * offsetY) * ((1-k) + signTheta * offsetTheta);
        distribution[i].array2D[j][k] = portion;
        signTheta = +1;
      }
      signY = +1;
    }
    signX = +1;
  }
}

//----Shifts the activity in the pose structure----//
void pathIntegrateCell(char xp, char yp, char thetap, float deltaTheta, float translation)
{
  //initialise loop variables
	char relativeX;
	char relativeY;
	char relativeTheta;

	char x;
	char y;
	char theta;

	float deltaPoseX = (cosDegrees(deltaTheta) * translation) / 0.5;/// (lengthX / sizeX);
  float deltaPoseY = (sinDegrees(deltaTheta) * translation) / 0.5; //(lengthX / sizeX);
	float deltaPoseTheta = deltaTheta / 60;//(360 / sizeTheta);

  int intOffsetX = (int) deltaPoseX; //only a whole number of cells moved
  int intOffsetY = (int) deltaPoseY;
  int intOffsetTheta = (int) deltaPoseTheta;

  getActivationDistribution(deltaPoseX - intOffsetX, deltaPoseY - intOffsetY, deltaPoseTheta - intOffsetTheta);

  for(relativeX = 0; relativeX < 2; relativeX++)
  {
  	x = getWrappedX(xp + intOffsetX + relativeX);
    for(relativeY = 0; relativeY < 2; relativeY++)
    {
      y = getWrappedY(yp + intOffsetY + relativeY);
    	for(relativeTheta = 0; relativeTheta < 2; relativeTheta++)
    	{
    	  theta = getWrappedTheta(thetap + intOffsetTheta + relativeTheta);
    	  poseWorld.poseActivity[x].array2D[y][theta] += distribution[relativeX].array2D[relativeY][relativeTheta] * poseWorld.poseActivity[xp].array2D[yp][thetap];
    	}
    }
  }
}

//----Sets up Pose Cells----//
void initialisePose()
{
	setupPoseStructure();
  excitationMatrixSetup();
  startCell();
  numActive = 1;
}

//----handles all cell stuff----//
void iterate(float stepSize)
{
	float activeSum;
  doExcitation(stepSize);
  activeSum = doInhibition(stepSize);
  doNormalisation(activeSum);
}

//----handles pose thing----//
void pose3D(float deltaTheta, float translation)
{
  //initialise loop variables
  char i;
  char j;
  char k;

  for(i = 0; i < 10; i++)
  {
    for(j = 0; j < 10; j++)
    {
      for(k = 0; k < 6; k++)
      {
        if(poseWorld.poseActivity[i].array2D[j][k] > 0) //if active
        {
          pathIntegrateCell(i, j, k, deltaTheta, translation);
        }
      }
    }
  }
  iterate(stepSize);
}

//                            //
//----Local View Functions----//
//                            //

//----Initialises the arrays to zero----//
void clearTemp()
{
  memset(localTemp, 0, 4*numNeuralUnits); //sets entire array to zero
  memset(localComparison, 0, 4*numNeuralUnits); //sets entire array to zero
}

//----Set the right neural units----//
void setRight()
{
	//This function allocates a proportion to each neural unit based on the value returned by the sonar sensor
	rightSonarValue = SensorValue(rightSonar);
	tempCalcR = 0;
	if(rightSonarValue <= firstUnit)
	{
		tempCalcR = (float) (((firstUnit - rightSonarValue)/firstUnit));
    localTemp[12] = (float) 1 - tempCalcR;
	}
  else if(rightSonarValue > firstUnit && rightSonarValue <= secondUnit)
  {
  	tempCalcR = (float) (secondUnit - rightSonarValue)/(secondUnit - firstUnit);
    localTemp[12] = tempCalcR;
  	localTemp[13] = 1 - tempCalcR;
  }
  else if(rightSonarValue > secondUnit && rightSonarValue <= thirdUnit)
  {
  	tempCalcR = (float) (thirdUnit - rightSonarValue)/(thirdUnit - secondUnit);
    localTemp[13] = tempCalcR;
  	localTemp[14] = 1 - tempCalcR;
  }
  else if(rightSonarValue > thirdUnit && rightSonarValue <= fourthUnit)
  {
  	tempCalcR = (float) (fourthUnit - rightSonarValue)/(fourthUnit - thirdUnit);
    localTemp[14] = tempCalcR;
  	localTemp[15] = 1 - tempCalcR;
  }
  else if(rightSonarValue > fourthUnit && rightSonarValue <= fifthUnit)
  {
  	tempCalcR = (float) (fifthUnit - rightSonarValue)/(fifthUnit - fourthUnit);
    localTemp[15] = tempCalcR;
  	localTemp[16] = 1 - tempCalcR;
  }
  else if(rightSonarValue > fifthUnit && rightSonarValue <= sixthUnit)
  {
  	tempCalcR = (float) (sixthUnit - rightSonarValue)/(sixthUnit - fifthUnit);
    localTemp[16] = tempCalcR;
  	localTemp[17] = 1 - tempCalcR;
  }
  else if(rightSonarValue > sixthUnit) //if greater than 195cm
  {
    localTemp[17] = 1;
  }
}

//----Set centre neural units----//
void setCentre()
{
	//This function allocates a proportion to each neural unit based on the value returned by the sonar sensor
	centreSonarValue = SensorValue(centreSonar);
	tempCalcC = 0;
	if(centreSonarValue <= firstUnit)
	{
		tempCalcC = (float) (((firstUnit - centreSonarValue)/firstUnit));
    localTemp[6] = (float) 1 - tempCalcC;
	}
  else if(centreSonarValue > firstUnit && centreSonarValue <= secondUnit)
  {
  	tempCalcC = (float) (secondUnit - centreSonarValue)/(secondUnit - firstUnit);
    localTemp[6] = tempCalcC;
  	localTemp[7] = 1 - tempCalcC;
  }
  else if(centreSonarValue > secondUnit && centreSonarValue <= thirdUnit)
  {
  	tempCalcC = (float) (thirdUnit - centreSonarValue)/(thirdUnit - secondUnit);
    localTemp[7] = tempCalcC;
  	localTemp[8] = 1 - tempCalcC;
  }
  else if(centreSonarValue > thirdUnit && centreSonarValue <= fourthUnit)
  {
  	tempCalcC = (float) (fourthUnit - centreSonarValue)/(fourthUnit - thirdUnit);
    localTemp[8] = tempCalcC;
  	localTemp[9] = 1 - tempCalcC;
  }
  else if(centreSonarValue > fourthUnit && centreSonarValue <= fifthUnit)
  {
  	tempCalcC = (float) (fifthUnit - centreSonarValue)/(fifthUnit - fourthUnit);
    localTemp[9] = tempCalcC;
  	localTemp[10] = 1 - tempCalcC;
  }
  else if(centreSonarValue > fifthUnit && centreSonarValue <= sixthUnit)
  {
  	tempCalcC = (float) (sixthUnit - centreSonarValue)/(sixthUnit - fifthUnit);
    localTemp[10] = tempCalcC;
  	localTemp[11] = 1 - tempCalcC;
  }
  else if(centreSonarValue > sixthUnit)
  {
    localTemp[11] = 1;
  }
}

//----set left neural units----//
void setLeft()
{
	//This function allocates a proportion to each neural unit based on the value returned by the sonar sensor
	leftSonarValue = SensorValue(leftSonar);
	tempCalcL = 0;
	if(leftSonarValue <= firstUnit)
	{
		tempCalcL = (float) (((firstUnit - leftSonarValue)/firstUnit));
    localTemp[0] = (float) 1 - tempCalcL;
	}
  else if(leftSonarValue > firstUnit && leftSonarValue <= secondUnit)
  {
  	tempCalcL = (float) (secondUnit - leftSonarValue)/(secondUnit - firstUnit);
    localTemp[0] = tempCalcL;
  	localTemp[1] = 1 - tempCalcL;
  }
  else if(leftSonarValue > secondUnit && leftSonarValue <= thirdUnit)
  {
  	tempCalcL = (float) (thirdUnit - leftSonarValue)/(thirdUnit - secondUnit);
    localTemp[1] = tempCalcL;
  	localTemp[2] = 1 - tempCalcL;
  }
  else if(leftSonarValue > thirdUnit && leftSonarValue <= fourthUnit)
  {
  	tempCalcL = (float) (fourthUnit - leftSonarValue)/(fourthUnit - thirdUnit);
    localTemp[2] = tempCalcL;
  	localTemp[3] = 1 - tempCalcL;
  }
  else if(leftSonarValue > fourthUnit && leftSonarValue <= fifthUnit)
  {
  	tempCalcL = (float) (fifthUnit - leftSonarValue)/(fifthUnit - fourthUnit);
    localTemp[3] = tempCalcL;
  	localTemp[4] = 1 - tempCalcL;
  }
  else if(leftSonarValue > fifthUnit && leftSonarValue <= sixthUnit)
  {
  	tempCalcL = (float) (sixthUnit - leftSonarValue)/(sixthUnit - fifthUnit);
    localTemp[4] = tempCalcL;
  	localTemp[5] = 1 - tempCalcL;
  }
  else if(leftSonarValue > sixthUnit)
  {
    localTemp[5] = 1;
  }
}

//---adds the association between local view and pose----//
void addAssociation(char cellNum)
{
  //creates an association between local view and pose - currently using max activated cell as the one needed but may end
	//up using estimated pose as in RAMP code
	char k;
	for(k=0; k<numNeuralUnits; k++)
	{
	  poseAssoc[cellNum].localView[k] = localTemp[k];
	}
	poseAssoc[cellNum].xCell = poseWorld.maxActivatedCell.x;
	poseAssoc[cellNum].yCell = poseWorld.maxActivatedCell.y;
	poseAssoc[cellNum].thetaCell = poseWorld.maxActivatedCell.theta;
}

//----Fills comparison with previous views----//
void fillLocalComparison(char cellNum)
{
	//fills the localComparison vector with the appropriate
	char k;
	memset(localComparison, 0, 4*numNeuralUnits);
	for(k=0; k<numNeuralUnits; k++)
	{
		if(poseAssoc[cellNum].localView[k]>0)
		{
	   localComparison[k] = poseAssoc[cellNum].localView[k];
	  }
	}
}

//----Dot multiply two vectors----//
float dotMultiply()
{
  char i;
  float dotValue = 0;
  for(i = 0; i < numNeuralUnits; i++)
  {
    if(localTemp[i]>0)
    {
      dotValue = dotValue + localTemp[i] * localComparison[i];
    }
  }
  return dotValue; //return the multiply
}

//----normalise the current view for processing----//
void normaliseTemp()
{
//will normalise the temp ||a|| = sqrt(a1^2 + a2^2 + a3^3)
//normalise by a/||a||
	float tempTotal = 0;
	char y;
	for(y = 0; y < numNeuralUnits; y++)
	{
		if(localTemp[y]>0) //only if over zero spend clock cycles
		{
		  tempTotal = tempTotal + localTemp[y]*localTemp[y]; //a.a
	  }
	}
	tempTotal = sqrt(tempTotal); //sqrt(a.a)
	for(y = 0; y < numNeuralUnits; y++)
	{
		if(localTemp[y]>0)
		{
	    localTemp[y] = (float) localTemp[y]/tempTotal;
	  }
	}
}

//----Gets local view and processes ready for comparison----//
void setTemp()
{
	//initalises temp, get sensor readings and sets the local temp to a normalised neural vector
  clearTemp();
	setLeft();
	setCentre();
	setRight();
	normaliseTemp();
}

//----Tune----//
void StarWars()
{
  //        180 = Tempo
  //          5 = Default octave
  //    Quarter = Default note length
  //        10% = Break between notes
  //
  PlayTone(  698,   15); wait1Msec( 167);  // Note(F, Duration(Eighth))
  PlayTone(  698,   15); wait1Msec( 167);  // Note(F, Duration(Eighth))
  PlayTone(  698,   15); wait1Msec( 167);  // Note(F, Duration(Eighth))
  PlayTone(  932,   90); wait1Msec(1000);  // Note(A#, Duration(Half .))
  PlayTone( 1047,   90); wait1Msec(1000);  // Note(F6, Duration(Half .))
  PlayTone(  933,   15); wait1Msec( 167);  // Note(D#6, Duration(Eighth))
  PlayTone(  880,   15); wait1Msec( 167);  // Note(D6, Duration(Eighth))
  PlayTone(  784,   15); wait1Msec( 167);  // Note(C6, Duration(Eighth))
  PlayTone( 1398,   90); wait1Msec(1000);  // Note(A#6, Duration(Half .))
  PlayTone( 1047,   45); wait1Msec( 500);  // Note(F6, Duration(Quarter .))
  PlayTone(  933,   15); wait1Msec( 167);  // Note(D#6, Duration(Eighth))
  PlayTone(  880,   15); wait1Msec( 167);  // Note(D6, Duration(Eighth))
  PlayTone(  784,   15); wait1Msec( 167);  // Note(C6, Duration(Eighth))
  PlayTone( 1398,   90); wait1Msec(1000);  // Note(A#6, Duration(Half .))
  PlayTone( 1047,   45); wait1Msec( 500);  // Note(F6, Duration(Quarter .))
  PlayTone(  933,   15); wait1Msec( 167);  // Note(D#6, Duration(Eighth))
  PlayTone(  880,   15); wait1Msec( 167);  // Note(D6, Duration(Eighth))
  PlayTone(  933,   15); wait1Msec( 167);  // Note(D#6, Duration(Eighth))
  PlayTone(  784,   60); wait1Msec( 667);  // Note(C6, Duration(Half))
  PlayTone(    0,   30); wait1Msec( 333);  // Note(Rest)
  PlayTone(  698,   15); wait1Msec( 167);  // Note(F, Duration(Eighth))
  PlayTone(  698,   15); wait1Msec( 167);  // Note(F, Duration(Eighth))
  PlayTone(  698,   15); wait1Msec( 167);  // Note(F, Duration(Eighth))
  PlayTone(  932,   90); wait1Msec(1000);  // Note(A#, Duration(Half .))
  PlayTone( 1047,   90); wait1Msec(1000);  // Note(F6, Duration(Half .))
  PlayTone(  933,   15); wait1Msec( 167);  // Note(D#6, Duration(Eighth))
  PlayTone(  880,   15); wait1Msec( 167);  // Note(D6, Duration(Eighth))
  PlayTone(  784,   15); wait1Msec( 167);  // Note(C6, Duration(Eighth))
  PlayTone( 1398,   90); wait1Msec(1000);  // Note(A#6, Duration(Half .))
  PlayTone( 1047,   45); wait1Msec( 500);  // Note(F6, Duration(Quarter .))
  PlayTone(  933,   15); wait1Msec( 167);  // Note(D#6, Duration(Eighth))
  PlayTone(  880,   15); wait1Msec( 167);  // Note(D6, Duration(Eighth))
  PlayTone(  784,   15); wait1Msec( 167);  // Note(C6, Duration(Eighth))
  PlayTone( 1398,   90); wait1Msec(1000);  // Note(A#6, Duration(Half .))
  PlayTone( 1047,   45); wait1Msec( 500);  // Note(F6, Duration(Quarter .))
  PlayTone(  933,   15); wait1Msec( 167);  // Note(D#6, Duration(Eighth))
  PlayTone(  880,   15); wait1Msec( 167);  // Note(D6, Duration(Eighth))
  PlayTone(  933,   15); wait1Msec( 167);  // Note(D#6, Duration(Eighth))
  PlayTone(  784,   60); wait1Msec( 667);  // Note(C6, Duration(Half))
  return;
}

//----Checks if there is a match, add activities, else creates a new association----//
void checkLocalCell()
{
	//uses a normalised version of the localTemp.  The comparison local cells are stored as normalised when 1st created
	char z;
	char match = 0;
	float dotTempValue = 0;
	float tempAngle = 0;
	if(nextEmptyCell == 0)
	{
	  //first localCellView
		addAssociation(nextEmptyCell);
    nextEmptyCell++;
    PlaySoundFile("! Attention.rso");
    while(bSoundActive) {}
	}
  else {
    for(z = 0; z<nextEmptyCell; z++)
    {
    	//search for a previous local cell that matches the current view to a certain degree
      fillLocalComparison(z);
      dotTempValue = dotMultiply();
      tempAngle = acos(dotTempValue);
      if(tempAngle<0.17) //if difference less than 10 degrees between vectors
      {
      	match = 1;
      	break; //save cycles break out
      }
    }
    if(match == 0)
    {//no match found - create a new local view cell
    	addAssociation(nextEmptyCell);
    	nextEmptyCell++;
    	nxtDisplayCenteredTextLine(6, "cell created");
      PlaySoundFile("! Attention.rso");
      while(bSoundActive) {}
    }
    else if(match == 1)
    {
    	char tempX, tempY, tempTheta;
    	tempX = poseAssoc[nextEmptyCell-1].xCell;
    	tempY = poseAssoc[nextEmptyCell-1].yCell;
    	tempTheta = poseAssoc[nextEmptyCell-1].thetaCell;
    	injectEnergy(stepSize, tempX, tempY, tempTheta);
    	nxtDisplayCenteredTextLine(6, "Energy Injected");
      PlaySoundFile("Woops.rso");
      while(bSoundActive) {}
    }
  }
}

//----Set direction and theta if turning----//
void handleDirection(char turn)
{
	switch (turn)
	{
	  case 'l':
	    if(currentDirection == 0)
	    {
	      currentDirection = 1;
	    	currentTheta = 90;
	    }
		  else if(currentDirection == 1)
		  {
		    currentDirection = 2;
		  	currentTheta = 180;
		  }
		  else if(currentDirection == 2)
		  {
		  	currentDirection = 3;
		  	currentTheta = 270;
		  }
		  else if(currentDirection == 3)
		  {
		  	currentDirection = 0;
		  	currentTheta = 0;
		  }
		  break;
		 case 'r':
	    if(currentDirection == 0)
	    {
	      currentDirection = 3;
	    	currentTheta = 270;
	    }
		  else if(currentDirection == 1)
		  {
		    currentDirection = 0;
		  	currentTheta = 0;
		  }
		  else if(currentDirection == 2)
		  {
		  	currentDirection = 1;
		  	currentTheta = 90;
		  }
		  else if(currentDirection == 3)
		  {
		  	currentDirection = 2;
		  	currentTheta = 180;
		  }
		  break;
		  case 'b':
	    if(currentDirection == 0)
	    {
	      currentDirection = 2;
	    	currentTheta = 180;
	    }
		  else if(currentDirection == 1)
		  {
		    currentDirection = 3;
		  	currentTheta = 270;
		  }
		  else if(currentDirection == 2)
		  {
		  	currentDirection = 0;
		  	currentTheta = 0;
		  }
		  else if(currentDirection == 3)
		  {
		  	currentDirection = 1;
		  	currentTheta = 90;
		  }
		  break;
		 default: break;
	}
}

//----Turns if need to----//
void doTurn()
{
//part of the testing reigme of the local cells
	//decided that anticlockwise is positive
	if(centreSonarValue<19)
	{
	  if(leftSonarValue > 19 && rightSonarValue < 19)
	  {
	  	nSyncedTurnRatio = 100;
	  	nMotorEncoderTarget[motorB] = 190;
	    motor[motorB] = -50;
	    while(nMotorRunState[motorB] != runStateIdle) {}
	    nSyncedTurnRatio = -100;
	  	nMotorEncoderTarget[motorB] = 190;
	    motor[motorB] = -50;
	    while(nMotorRunState[motorB] != runStateIdle) {}
	    handleDirection('l');
	  }
		else if(leftSonarValue < 19 && rightSonarValue > 19)
	  {
	  	nSyncedTurnRatio = 100;
	  	nMotorEncoderTarget[motorB] = 190;
	    motor[motorB] = -50;
	    while(nMotorRunState[motorB] != runStateIdle) {}
	    nSyncedTurnRatio = -100;
	  	nMotorEncoderTarget[motorB] = 190;
	    motor[motorB] = 50;
	    while(nMotorRunState[motorB] != runStateIdle) {}
	    handleDirection('r');
	  }
		else if(leftSonarValue < 19 && rightSonarValue < 19)
	  {
	  	nSyncedTurnRatio = 100;
	  	nMotorEncoderTarget[motorB] = 190;
	    motor[motorB] = -50;
	    while(nMotorRunState[motorB] != runStateIdle) {}
	    nSyncedTurnRatio = -100;
	  	nMotorEncoderTarget[motorB] = 370;
	    motor[motorB] = 50;
	    while(nMotorRunState[motorB] != runStateIdle) {}
      handleDirection('b');
	   }
	  else
	  {
	  	nSyncedTurnRatio = 100;
	  	nMotorEncoderTarget[motorB] = 190;
	    motor[motorB] = -50;
	    while(nMotorRunState[motorB] != runStateIdle) {}
	  	nSyncedTurnRatio = -100;
	  	nMotorEncoderTarget[motorB] = 190;
	    motor[motorB] = -50;
	    while(nMotorRunState[motorB] != runStateIdle) {}
      handleDirection('l');
	  }
  }
}

//----main----//
task main ()
{
	nxtDisplayCenteredTextLine(3, "Roaming");
	nxtDisplayCenteredTextLine(5, "This is a test");
	initialisePose(); //set up
	iterate(stepSize); //run excitation etc
	currentDirection = 0; //set initial
  currentTheta = 0;
  setTemp();  //get local view
  checkLocalCell(); //create first association
	while(nextEmptyCell<numLocalCells)
	{
		alive(); //stop NXT from sleeping
		//eraseDisplay();

		//nxtDisplayCenteredTextLine(2, "Num Active: - %4d",numActive);
		char lastCellNum = nextEmptyCell;
	  nSyncedMotors = synchBC;
	  nSyncedTurnRatio = 101; //move forward
    nMotorEncoderTarget[motorB] = 180;
	  motor[motorB] =60;
    while(nMotorRunState[motorB] != runStateIdle) {}
    if(currentDirection == 0)
    {
      pose3D(currentTheta,0.09); //180 encoder clicks is 9cm
    }
    else if(currentDirection == 1)
    {
    	pose3D(currentTheta,0.09);
    }
    else if(currentDirection == 2)
    {
    	pose3D(currentTheta,0.09);
    }
    else if(currentDirection ==3)
    {
    	pose3D(currentTheta,0.09);
    }
    setTemp();
    checkLocalCell();
    doTurn();

    char tempX, tempY, tempTheta;
    tempX = (char) poseAssoc[nextEmptyCell-1].xCell;
    tempY = (char) poseAssoc[nextEmptyCell-1].yCell;
    tempTheta = (char) poseAssoc[nextEmptyCell-1].thetaCell;
    //display data
    eraseDisplay();
    nxtDisplayTextLine(1, "pose: %2d,%2d", tempX, tempY);
    nxtDisplayStringAt(68, 55, ",%2d", tempTheta);
    nxtDisplayTextLine(2, "Num Act.: %3d",numActive);
    //store data
    AddToDatalog(1,tempX);
    AddToDatalog(2,tempY);
    AddToDatalog(3,tempTheta);
    AddToDatalog('t');
 // wait1Msec(200);

  }
  SaveNxtDatalog();
  //StarWars();
}

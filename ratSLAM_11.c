#pragma config(Sensor, S1,     leftSonar,           sensorSONAR)
#pragma config(Sensor, S2,     centreSonar,         sensorSONAR)
#pragma config(Sensor, S3,     rightSonar,          sensorSONAR)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////
//      Title:- ratSLAM - local, pose and experience
//      Author:- Lachlan Smith (RobotC)
//               Mark Wakabayashi (Java version)
//               Michael Milford (original algorithim/c code)
//      Purpose:- create an experience map
//
//
//////////////////////////////////////////////////////////////////////////////////

/*
|
| each full rotation of the wheel is 360 encoders clicks and 18cm (0.018m)
|
| Still pondering whether to have an array holding just active cells or to
| search the entire pose structure
|
| just discovered while u cant pass array u can pass structures holding array

*/

//----include files----//
#include "math.h";
#include "localNeural_reduced.h";
#include "poseCell.h";
#include "experienceMap.h";


//----General In-Module Variables----//
int numActive = 0; //number of active cells
int currentTheta = 0; //theta for pose and turns
int currentDirection = 0; //direction for pose and turnsmaybe
int changeTheta = 0;
int localTemp[numNeuralUnits]; //holds the temporary neural value
int localComparison[numNeuralUnits]; //what the local cell data is loaded into
char nextEmptyCell = 0; //used for holding the next empty cell in the localcell Struct
int nextID = 0;
int nextLink = 0;
char read = 0;
vector3DE encoderData;
PoseCellPosition maxActivatedCellPose;
localViewCell localTempView;
float averageEncoder = 0;

//trial
typedef enum
{
  stateRun,
  stateStop,
} TStates;

TStates nCurrState;
TStates nWallState;

//----Specific global variables for functions (in an attempt to save memory :))----//
//path integratation
float deltaPoseX;/// (lengthX / sizeX);
float deltaPoseY; //(lengthX / sizeX);
float deltaPoseTheta;//(360 / sizeTheta);
int intOffsetX; //only a whole number of cells moved
int intOffsetY;
int intOffsetTheta;

//local view neural units
int tempCalc = 0;

//loop global variables
char i;
char j;
char k;

//path integration and excitation
char relativeX;
char relativeY;
char relativeTheta;

//Sonar
int rightSonarValue = 0;
int leftSonarValue = 0;
int centreSonarValue = 0;

//Wall Follower
int desiredLeft = 10;
int desiredSpeed = 20;
float kW = 60;
float alpha = 0.5;
float beta1 = kW/(desiredSpeed);
float beta0 = alpha * beta1;
//                           //
//----Pose Cell Functions----//
//                           //

//----Change which struct is used----//
void changeRead()
{
  read = !read;
}

//----initialises the start cell and sets starting activation----//
void startCell()
{
  maxActivatedCell.x = 5;
  maxActivatedCell.y = 5;
  maxActivatedCell.theta = 0;
  maxActivatedCell.act = 0.5;
  poseActivity1[5].array2D[5][0] = 0.5;
}

//----initalises all pose cells as inactive and sets all pose activity to zero----//
void setupPoseStructure()
{
  memset(poseActivity1, 0, numberOfCells);
  memset(poseActivity2,0, numberOfCells);
  memset(maxActivatedCell, 0, 7);
  memset(poseAssoc, 0, 33*numLocalCells);
  memset(encoderData,0,12);
  memset(maxActivatedCellPose,0,3);
  memset(localTempView,0,30);
}

//----Excitation matrix----//
void excitationMatrixSetup()
{
  //done in matlab - probably should check if right
  excitation_Weights[0].array2D[0][0] =  0.0495;
  excitation_Weights[0].array2D[0][1] =  0.3655;
  excitation_Weights[0].array2D[0][2] =  0.0495;
  excitation_Weights[0].array2D[1][0] =  0.1727;
  excitation_Weights[0].array2D[1][1] =  1.2757;
  excitation_Weights[0].array2D[1][2] =  0.1727;
  excitation_Weights[0].array2D[2][0] =  0.0495;
  excitation_Weights[0].array2D[2][1] =  0.3655;
  excitation_Weights[0].array2D[2][2] =  0.0495;

  excitation_Weights[1].array2D[0][0] =  0.1727;
  excitation_Weights[1].array2D[0][1] =  1.2757;
  excitation_Weights[1].array2D[0][2] =  0.1727;
  excitation_Weights[1].array2D[1][0] =  0.6026;
  excitation_Weights[1].array2D[1][1] =  4.4528;
  excitation_Weights[1].array2D[1][2] =  0.6026;
  excitation_Weights[1].array2D[2][0] =  0.1727;
  excitation_Weights[1].array2D[2][1] =  1.2757;
  excitation_Weights[1].array2D[2][2] =  0.1727;

  excitation_Weights[2].array2D[0][0] =  0.0495;
  excitation_Weights[2].array2D[0][1] =  0.3655;
  excitation_Weights[2].array2D[0][2] =  0.0495;
  excitation_Weights[2].array2D[1][0] =  0.1727;
  excitation_Weights[2].array2D[1][1] =  1.2757;
  excitation_Weights[2].array2D[1][2] =  0.1727;
  excitation_Weights[2].array2D[2][0] =  0.0495;
  excitation_Weights[2].array2D[2][1] =  0.3655;
  excitation_Weights[2].array2D[2][2] =  0.0495;
}

//----Clears Encoders - used to ensure correct rotation angles----//
void clearEncoders()
{
	//have to unsynch motors as when clearing the master the slave wont clear
	//and attempting to clear the slave causes an error
	nSyncedMotors = synchNone;
  nMotorEncoder[motorC] = 0;
  nMotorEncoder[motorB] = 0;
}

void setEncoderData(int angle)
{
  encoderData.x = encoderData.x + (int) (cosDegrees(angle)*averageEncoder);
  encoderData.y = encoderData.y + (int) (sinDegrees(angle)*averageEncoder);
  encoderData.z = angle;
}

//----Determine rotation of robot from encoder values----//
int getRotation()
{
	float motorBCount = nMotorEncoder[motorB];
	float motorCCount = nMotorEncoder[motorC];
	motorBCount /= 190; //distance between wheels in encoder clicks
	motorCCount /= 190;
	float thetaOne;
	float thetaTwo;
	float thetaThree;
	if(motorBCount<0)
	{
	  motorBCount *= -1;
	  thetaOne = getDegrees(atan(motorBCount));
	  thetaTwo = getDegrees(atan(motorCCount));
    return (int) -(thetaOne + thetaTwo);
	}
	else if(motorCCount<0)
	{
    motorCCount *= -1;
	  thetaOne = getDegrees(atan(motorBCount));
	  thetaTwo = getDegrees(atan(motorCCount));
	  return (int) (thetaOne + thetaTwo);
  }
  else if(motorCCount < 0 && motorBCount < 0)
  {
  	motorBCount *= -1;
  	motorCCount *= -1;
  	thetaOne = getDegrees(atan(motorBCount));
	  thetaTwo = getDegrees(atan(motorCCount));
	  return (int) (thetaOne + thetaTwo);
  }
  else
  {
  	thetaOne = getDegrees(atan(motorBCount));
	  thetaTwo = getDegrees(atan(motorCCount));
	  return (int) (thetaOne - thetaTwo);
  }
  return (int) thetaThree;
}


//----Wrapping values in x-direction in Pose structure----//
char getWrappedX(char indexX)
{
  if(indexX < 0)
  {
    return (indexX + sizeX);
  }
  else if(indexX >= sizeX)
  {
    return (indexX - sizeX);
  }
  return indexX;
}

//----Wrapping values in y-direction in Pose structure----//
char getWrappedY(char indexY)
{
  if(indexY < 0)
  {
    return (indexY + sizeY);
  }
  else if(indexY >= sizeY)
  {
    return (indexY - sizeY);
  }
  return indexY;
}

//----Wrapping values in theta-direction in Pose structure----//
char getWrappedTheta(char indexTheta)
{
  if(indexTheta < 0)
  {
    return (indexTheta + sizeTheta);
  }
  else if(indexTheta >= sizeTheta)
  {
    return (indexTheta - sizeTheta);
  }
  return indexTheta;
}

//----Sets activation in cell and handles maximum cell----//
void setActivation(char cellX, char cellY, char cellTheta, float activation)
{
	float previousActivation; //previous activation of a cell
  if(read)
  {
	  //set values
    previousActivation = poseActivity2[cellX].array2D[cellY][cellTheta];
    if(previousActivation == activation)
    {//if the same do nothing, exit function
      return;
    }
    poseActivity2[cellX].array2D[cellY][cellTheta] = activation; //else set activation

    if(activation > poseActivity2[maxActivatedCell.x].array2D[maxActivatedCell.y][maxActivatedCell.theta])
    {//if activation greater than max, then set as maximum
      maxActivatedCell.x = cellX;
      maxActivatedCell.y = cellY;
      maxActivatedCell.theta = cellTheta;
      maxActivatedCell.act = activation;
    }
  }
  else
  {
	  //set values
    previousActivation = poseActivity1[cellX].array2D[cellY][cellTheta];
    if(previousActivation == activation)
    {//if the same do nothing, exit function
      return;
    }
    poseActivity1[cellX].array2D[cellY][cellTheta] = activation; //else set activation

    if(activation > poseActivity1[maxActivatedCell.x].array2D[maxActivatedCell.y][maxActivatedCell.theta])
    {//if activation greater than max, then set as maximum
      maxActivatedCell.x = cellX;
      maxActivatedCell.y = cellY;
      maxActivatedCell.theta = cellTheta;
      maxActivatedCell.act = activation;
    }
  }

}

//----Injects additional activity into cells----//
void injectEnergy (float stepSize, char xCell, char yCell, char thetaCell)
{
	float previousActivation;
	if(read)
	{
	  previousActivation = poseActivity2[poseAssoc.xCell].array2D[poseAssoc.yCell][poseAssoc.thetaCell];
	}
	else
	{
		previousActivation = poseActivity1[poseAssoc.xCell].array2D[poseAssoc.yCell][poseAssoc.thetaCell];
	}
  setActivation(poseAssoc.xCell,poseAssoc.yCell,poseAssoc.thetaCell, previousActivation + injectionStrength * stepSize);
}

//----Excites neighbouring cells----//
void doExcitation(float stepSize)
{
  if(read)
  {
    memcpy(poseActivity2, poseActivity1, numberOfCells); //fillposeActivity12();

    for(i = 0; i < sizeX; i++)
    {
     for(j = 0; j < sizeY; j++)
      {
        for(k = 0; k < sizeTheta; k++)
        {
          if(poseActivity1[i].array2D[j][k] > 0) //if cell active
          {
        	  float thisActivation = poseActivity1[i].array2D[j][k];
        	  for (relativeX = -influenceXY; relativeX <= influenceXY; relativeX++)
        	  {
              char neighbourX = getWrappedX(i + relativeX);
              for(relativeY = - influenceXY; relativeY<= influenceXY; relativeY++)
              {
                char neighbourY = getWrappedY(j + relativeY);
                for(relativeTheta = -influenceTheta; relativeTheta <= influenceTheta; relativeTheta++)
                {
                  char neighbourTheta = getWrappedTheta(k + relativeTheta);
              	  float excitationWeight = excitation_Weights[relativeX + influenceXY].array2D[relativeY + influenceXY][relativeTheta + influenceTheta];
                  poseActivity2[neighbourX].array2D[neighbourY][neighbourTheta] += (thisActivation * excitationWeight * stepSize);
                }
              }
        	  }
          }
        }
      }
    }
  }
  else
  {
    memcpy(poseActivity1, poseActivity2, numberOfCells); //fillposeActivity12();

    for(i = 0; i < sizeX; i++)
    {
     for(j = 0; j < sizeY; j++)
      {
        for(k = 0; k < sizeTheta; k++)
        {
          if(poseActivity2[i].array2D[j][k] > 0) //if cell active
          {
        	  float thisActivation = poseActivity2[i].array2D[j][k];
        	  for (relativeX = -influenceXY; relativeX <= influenceXY; relativeX++)
        	  {
              char neighbourX = getWrappedX(i + relativeX);
              for(relativeY = - influenceXY; relativeY<= influenceXY; relativeY++)
              {
                char neighbourY = getWrappedY(j + relativeY);
                for(relativeTheta = -influenceTheta; relativeTheta <= influenceTheta; relativeTheta++)
                {
                  char neighbourTheta = getWrappedTheta(k + relativeTheta);
              	  float excitationWeight = excitation_Weights[relativeX + influenceXY].array2D[relativeY + influenceXY][relativeTheta + influenceTheta];
                  poseActivity1[neighbourX].array2D[neighbourY][neighbourTheta] += (thisActivation * excitationWeight * stepSize);
                }
              }
        	  }
          }
        }
      }
    }
  }
}

//----Inhibits neighbouring cells----//
float doInhibition(float stepSize)
{
  float activationSum = 0;
  float activation = 0;
  numActive = 0; //clear number of active cells counter

  if(read)
  {
    for(i = 0; i < sizeX; i++)
    {
      for(j = 0; j < sizeY; j++)
      {
        for(k = 0; k < sizeTheta; k++)
        {
          if(poseActivity2[i].array2D[j][k] > 0) //if cell active
          {
        	  activation = poseActivity2[i].array2D[j][k] - (0.014 * stepSize);
            if(activation <=0)
            {
              activation = 0; //cant have negative activity
              poseActivity2[i].array2D[j][k] = activation;
            }
            else
            {
          	  //have decided that as only max cells will be above zero why bother checking if maximum if = 0
          	  setActivation(i, j, k, activation); //set activation and see if is maximum
          	  activationSum += activation;
              numActive++; //increase number of active cells
            }
          }
        }
      }
    }
  }
  else
  {
    for(i = 0; i < sizeX; i++)
    {
      for(j = 0; j < sizeY; j++)
      {
        for(k = 0; k < sizeTheta; k++)
        {
          if(poseActivity1[i].array2D[j][k] > 0) //if cell active
          {
        	  activation = poseActivity1[i].array2D[j][k] - (0.014 * stepSize);
            if(activation <=0)
            {
              activation = 0; //cant have negative activity
              poseActivity1[i].array2D[j][k] = activation;
            }
            else
            {
          	  //have decided that as only max cells will be above zero why bother checking if maximum if = 0
          	  setActivation(i, j, k, activation); //set activation and see if is maximum
          	  activationSum += activation;
              numActive++; //increase number of active cells
            }
          }
        }
      }
    }
  }
  return activationSum;
}

//----Normalises the activity in the pose matrix----//
void doNormalisation(float activationSum)
{//requires activationSum from inhibition

  //initalise loop variables
  if(read)
  {
    for(i = 0; i < sizeX; i++)
    {
      for(j = 0; j < sizeY; j++)
      {
        for(k = 0; k < sizeTheta; k++)
        {
          if(poseActivity2[i].array2D[j][k] > 0) //if active
          {
          poseActivity2[i].array2D[j][k] = (poseActivity2[i].array2D[j][k] / activationSum); //normalise
          }
        }
      }
    }
    maxActivatedCell.act = poseActivity2[maxActivatedCell.x].array2D[maxActivatedCell.y][maxActivatedCell.theta];
  }
  else
  {
    for(i = 0; i < sizeX; i++)
    {
      for(j = 0; j < sizeY; j++)
      {
        for(k = 0; k < sizeTheta; k++)
        {
          if(poseActivity1[i].array2D[j][k] > 0) //if active
          {
          poseActivity1[i].array2D[j][k] = (poseActivity1[i].array2D[j][k] / activationSum); //normalise
          }
        }
      }
    }
    maxActivatedCell.act = poseActivity1[maxActivatedCell.x].array2D[maxActivatedCell.y][maxActivatedCell.theta];
  }
}

//----Sets up the distribution for activity----//
void getActivationDistribution(float offsetX, float offsetY, float offsetTheta)
{
  //initialise variables
  char signX;
  char signY;
  char signTheta;
  float portion;

  signX = -1;
  for(i = 0; i < 2; i++)
  {
    signY = -1;
    for(j = 0; j < 2; j++)
    {
      signTheta = -1;
      for(k = 0; k < 2; k++)
      {
        portion =  ((1-i) + signX * offsetX) * ((1-j) + signY * offsetY) * ((1-k) + signTheta * offsetTheta);
        distribution[i].array2D[j][k] = portion;
        signTheta = +1;
      }
      signY = +1;
    }
    signX = +1;
  }
}

//----Shifts the activity in the pose structure----//
void pathIntegrateCell(char xp, char yp, char thetap, float deltaTheta, float translation)
{
  //initialise loop variables
	char x;
	char y;
	char theta;

	if(read)
	{
    for(relativeX = 0; relativeX < 2; relativeX++)
    {
      x = getWrappedX(xp + intOffsetX + relativeX);
      for(relativeY = 0; relativeY < 2; relativeY++)
      {
        y = getWrappedY(yp + intOffsetY + relativeY);
    	  for(relativeTheta = 0; relativeTheta < 2; relativeTheta++)
    	  {
    	    theta = getWrappedTheta(thetap + intOffsetTheta + relativeTheta);
    	    poseActivity2[x].array2D[y][theta] += distribution[relativeX].array2D[relativeY][relativeTheta] * poseActivity1[xp].array2D[yp][thetap];
    	  }
      }
    }
  }
  else
	{
    for(relativeX = 0; relativeX < 2; relativeX++)
    {
      x = getWrappedX(xp + intOffsetX + relativeX);
      for(relativeY = 0; relativeY < 2; relativeY++)
      {
        y = getWrappedY(yp + intOffsetY + relativeY);
    	  for(relativeTheta = 0; relativeTheta < 2; relativeTheta++)
    	  {
    	    theta = getWrappedTheta(thetap + intOffsetTheta + relativeTheta);
    	    poseActivity1[x].array2D[y][theta] += distribution[relativeX].array2D[relativeY][relativeTheta] * poseActivity2[xp].array2D[yp][thetap];
    	  }
      }
    }
  }

}

//----Sets up Pose Cells----//
void initialisePose()
{
	setupPoseStructure();
  excitationMatrixSetup();
  startCell();
  numActive = 1;
  changeRead();
}

//----handles all cell stuff----//
void iterate(float stepSize)
{
	float activeSum;
	doExcitation(stepSize);
  activeSum = doInhibition(stepSize);
  doNormalisation(activeSum);
}

void iterateExperience(float stepSize)
{
  grabData();
  iterateMap(stepSize);
}

//----handles pose thing----//
void pose3D(float deltaTheta, float translation)
{
  //initialise loop variables
  deltaPoseX = (cosDegrees(currentDirection) * translation) / 0.5;/// (lengthX / sizeX);
  deltaPoseY = (sinDegrees(currentDirection) * translation) / 0.5; //(lengthX / sizeX);
	deltaPoseTheta = deltaTheta / 60;//(360 / sizeTheta);

  intOffsetX = (int) deltaPoseX; //only a whole number of cells moved
  intOffsetY = (int) deltaPoseY;
  intOffsetTheta = (int) deltaPoseTheta;

  getActivationDistribution(deltaPoseX - intOffsetX, deltaPoseY - intOffsetY, deltaPoseTheta - intOffsetTheta);

  changeRead();

  if(read)
  {
    memset(poseActivity2, 0, numberOfCells); //a zero matrix to perform path integration on

    for(i = 0; i < sizeX; i++)
    {
      for(j = 0; j < sizeY; j++)
      {
        for(k = 0; k < sizeTheta; k++)
        {
          if(poseActivity1[i].array2D[j][k] > 0) //if active
          {
            pathIntegrateCell(i, j, k, deltaTheta, translation);
          }
        }
      }
    }
  }
  else
  {
    memset(poseActivity1, 0, numberOfCells); //a zero matrix to perform path integration on

    for(i = 0; i < sizeX; i++)
    {
      for(j = 0; j < sizeY; j++)
      {
        for(k = 0; k < sizeTheta; k++)
        {
          if(poseActivity2[i].array2D[j][k] > 0) //if active
          {
            pathIntegrateCell(i, j, k, deltaTheta, translation);
          }
        }
      }
    }
  }
  changeRead();
}

void drawRect(char xCo, char yCo, char percent)
{
  char startX = xCo * 6 + 2;
  char startY = yCo * 6 + 2;
  int count = 0;
  char yOffset = 0;
  char xOffset = 0;
  char s;

  if(percent == 100)
  {
    nxtFillRect(startX, startY, startX + 5, startY + 5);
  }
  else if(percent == 85)
  {
    while(count<6)
    {
      for(s = 0; s<6; s++)
      {
        if(eightyFivePercent[s+xOffset]==1)
        {
          nxtSetPixel(startX+s, startY + yOffset);
        }
      }
      xOffset += 6;
      yOffset+=1;
      count+=1;
    }
  }
  else if(percent == 75)
  {
    while(count<6)
    {
      for(s = 0; s<6; s++)
      {
        if(seventyFivePercent[s+xOffset]==1)
        {
         nxtSetPixel(startX+s, startY + yOffset);
        }
      }
      xOffset += 6;
      yOffset+=1;
      count+=1;
    }
  }
  else if(percent == 67)
  {
   while(count<6)
   {
      for(s = 0; s<6; s++)
      {
        if(sixtySevenPercent[s+xOffset]==1)
        {
         nxtSetPixel(startX+s, startY + yOffset);
        }
      }
      xOffset += 6;
      yOffset+=1;
      count+=1;
    }
  }
  else if(percent == 50)
  {
   while(count<6)
   {
      for(s = 0; s<6; s++)
      {
        if(fiftyPercent[s+xOffset]==1)
        {
          nxtSetPixel(startX+s, startY + yOffset);
        }
      }
      xOffset += 6;
      yOffset+=1;
      count+=1;
    }
  }
  else if(percent == 33)
  {
    while(count<6)
    {
      for(s = 0; s<6; s++)
      {
        if(thirtyThreePercent[s+xOffset]==1)
        {
         nxtSetPixel(startX+s, startY + yOffset);
        }
      }
      xOffset += 6;
      yOffset+=1;
      count+=1;
    }
  }
  else if(percent == 25)
  {
    while(count<6)
    {
      for(s = 0; s<6; s++)
      {
        if(twentyfivePercent[s+xOffset]==1)
        {
           nxtSetPixel(startX+s, startY + yOffset);
        }
      }
      xOffset += 6;
      yOffset+=1;
      count+=1;
    }
  }
  else if(percent == 15)
  {
    while(count<6)
    {
      for(s = 0; s<6; s++)
      {
        if(fifteenPercent[s+xOffset]==1)
        {
          nxtSetPixel(startX+s, startY + yOffset);
        }
      }
      xOffset += 6;
      yOffset+=1;
      count+=1;
    }
  }
  else if(percent == 2)
  {
    while(count<6)
    {
      for(s = 0; s<6; s++)
      {
        if(twoPercent[s+xOffset]==1)
        {
          nxtSetPixel(startX+s, startY + yOffset);
        }
      }
      xOffset += 6;
      yOffset+=1;
      count+=1;
    }
  }
}

//                            //
//----Local View Functions----//
//                            //

//----Initialises the arrays to zero----//
void clearTemp()
{
  memset(localTemp, 0, 2*numNeuralUnits); //sets entire array to zero
  memset(localComparison, 0, 2*numNeuralUnits); //sets entire array to zero
}

//----Set the right neural units----//
void setRight(int rightSonarValue)
{
	//This function allocates a proportion to each neural unit based on the value returned by the sonar sensor
	//rightSonarValue = SensorValue(rightSonar);
	tempCalc = 0;
	if(rightSonarValue <= firstUnit)
	{
		tempCalc = (int) ((100*(firstUnit - rightSonarValue)/firstUnit));
    localTemp[10] = (int) 100 - tempCalc;
	}
  else if(rightSonarValue > firstUnit && rightSonarValue <= secondUnit)
  {
  	tempCalc = (int) (100*(secondUnit - rightSonarValue)/(secondUnit - firstUnit));
    localTemp[10] = tempCalc;
  	localTemp[11] = 100 - tempCalc;
  }
  else if(rightSonarValue > secondUnit && rightSonarValue <= thirdUnit)
  {
  	tempCalc = (int) (100*(thirdUnit - rightSonarValue)/(thirdUnit - secondUnit));
    localTemp[11] = tempCalc;
  	localTemp[12] = 100 - tempCalc;
  }
  else if(rightSonarValue > thirdUnit && rightSonarValue <= fourthUnit)
  {
  	tempCalc = (int) (100*(fourthUnit - rightSonarValue)/(fourthUnit - thirdUnit));
    localTemp[12] = tempCalc;
  	localTemp[13] = 100 - tempCalc;
  }
  else if(rightSonarValue > fourthUnit && rightSonarValue <= fifthUnit)
  {
  	tempCalc = (int) (100*(fifthUnit - rightSonarValue)/(fifthUnit - fourthUnit));
    localTemp[13] = tempCalc;
  	localTemp[14] = 100 - tempCalc;
  }
  else if(rightSonarValue > fifthUnit)
  {
    localTemp[14] = 100;
  }
}

//----Set centre neural units----//
void setCentre(int centreSonarValue)
{
	//This function allocates a proportion to each neural unit based on the value returned by the sonar sensor
	//centreSonarValue = SensorValue(centreSonar);
	tempCalc = 0;
	if(centreSonarValue <= firstUnit)
	{
		tempCalc = (int) ((100*(firstUnit - centreSonarValue)/firstUnit));
    localTemp[5] = (int) 100 - tempCalc;
	}
  else if(centreSonarValue > firstUnit && centreSonarValue <= secondUnit)
  {
  	tempCalc = (int) (100*(secondUnit - centreSonarValue)/(secondUnit - firstUnit));
    localTemp[5] = tempCalc;
  	localTemp[6] = 100 - tempCalc;
  }
  else if(centreSonarValue > secondUnit && centreSonarValue <= thirdUnit)
  {
  	tempCalc = (int) (100*(thirdUnit - centreSonarValue)/(thirdUnit - secondUnit));
    localTemp[6] = tempCalc;
  	localTemp[7] = 100 - tempCalc;
  }
  else if(centreSonarValue > thirdUnit && centreSonarValue <= fourthUnit)
  {
  	tempCalc = (int) (100*(fourthUnit - centreSonarValue)/(fourthUnit - thirdUnit));
    localTemp[7] = tempCalc;
  	localTemp[8] = 100 - tempCalc;
  }
  else if(centreSonarValue > fourthUnit && centreSonarValue <= fifthUnit)
  {
  	tempCalc = (int) (100*(fifthUnit - centreSonarValue)/(fifthUnit - fourthUnit));
    localTemp[8] = tempCalc;
  	localTemp[9] = 100 - tempCalc;
  }
  else if(centreSonarValue > fifthUnit)
  {
    localTemp[9] = 100;
  }
}

//----set left neural units----//
void setLeft(int leftSonarValue)
{
	//This function allocates a proportion to each neural unit based on the value returned by the sonar sensor
	//leftSonarValue = SensorValue(leftSonar);
	tempCalc = 0;
	if(leftSonarValue <= firstUnit)
	{
		tempCalc = (int) ((100*(firstUnit - leftSonarValue)/firstUnit));
    localTemp[0] = (int) 100 - tempCalc;
	}
  else if(leftSonarValue > firstUnit && leftSonarValue <= secondUnit)
  {
  	tempCalc = (int) (100*(secondUnit - leftSonarValue)/(secondUnit - firstUnit));
    localTemp[0] = tempCalc;
  	localTemp[1] = 100 - tempCalc;
  }
  else if(leftSonarValue > secondUnit && leftSonarValue <= thirdUnit)
  {
  	tempCalc = (int) (100*(thirdUnit - leftSonarValue)/(thirdUnit - secondUnit));
    localTemp[1] = tempCalc;
  	localTemp[2] = 100 - tempCalc;
  }
  else if(leftSonarValue > thirdUnit && leftSonarValue <= fourthUnit)
  {
  	tempCalc = (int) (100*(fourthUnit - leftSonarValue)/(fourthUnit - thirdUnit));
    localTemp[2] = tempCalc;
  	localTemp[3] = 100 - tempCalc;
  }
  else if(leftSonarValue > fourthUnit && leftSonarValue <= fifthUnit)
  {
  	tempCalc = (int) (100*(fifthUnit - leftSonarValue)/(fifthUnit - fourthUnit));
    localTemp[3] = tempCalc;
  	localTemp[4] = 100 - tempCalc;
  }
  else if(leftSonarValue > fifthUnit)
  {
    localTemp[4] = 100;
  }
}

//---adds the association between local view and pose----//
void addAssociation(char cellNum)
{
  //creates an association between local view and pose - currently using max activated cell as the one needed but may end
	//up using estimated pose as in RAMP code
	memcpy(poseAssoc[cellNum].localView,localTemp,numNeuralUnits*2);
	poseAssoc[cellNum].xCell = maxActivatedCell.x;
	poseAssoc[cellNum].yCell = maxActivatedCell.y;
	poseAssoc[cellNum].thetaCell = maxActivatedCell.theta;
}

//----Dot multiply two vectors----//
float dotMultiply()
{
  float dotValue = 0;
  for(i = 0; i < numNeuralUnits; i++)
  {
    if(localTemp[i]>0)
    {
      dotValue = dotValue + (localTemp[i] * localComparison[i]);
    }
  }
  dotValue = (float) (dotValue/10000);
  return dotValue; //return the multiply
}

//----normalise the current view for processing----//
void normaliseTemp()
{
//will normalise the temp ||a|| = sqrt(a1^2 + a2^2 + a3^3)
//normalise by a/||a|| ----THIS IS A DODGY NORMALISE----
	float tempTotal = 0;
	char y;
	for(y = 0; y < numNeuralUnits; y++)
	{
		if(localTemp[y]>0) //only if over zero spend clock cycles
		{
		  tempTotal = tempTotal + localTemp[y]*localTemp[y]; //a.a
	  }
	}
	tempTotal =  (sqrt(tempTotal)); //sqrt(a.a)
	for(y = 0; y < numNeuralUnits; y++)
	{
		if(localTemp[y]>0)
		{
	    localTemp[y] = (int) (100*(localTemp[y]/tempTotal));
	  }
	}
}

//----Gets local view and processes ready for comparison----//
void setTemp()
{
	//initalises temp, get sensor readings and sets the local temp to a normalised neural vector
  clearTemp();
	rightSonarValue = SensorValue(rightSonar); //obvious
  leftSonarValue = SensorValue(leftSonar);
  centreSonarValue = SensorValue(centreSonar);
  setLeft(leftSonarValue);
	setCentre(centreSonarValue);
	setRight(rightSonarValue);
	normaliseTemp();
}

//----Checks if there is a match, add activities, else creates a new association----//
void checkLocalCell()
{
	//uses a normalised version of the localTemp.  The comparison local cells are stored as normalised when 1st created
	char z;
	char match = 0;
	float dotTempValue = 0;
	float tempAngle = 0;
	if(nextEmptyCell == 0)
	{
	  //first localCellView
		addAssociation(nextEmptyCell);
    nextEmptyCell++;
    PlaySound(soundFastUpwardTones);
    while(bSoundActive) {}
	}
  else {
    for(z = 0; z<nextEmptyCell; z++)
    {
    	//search for a previous local cell that matches the current view to a certain degree
      memcpy(localComparison,poseAssoc[z].localView,numNeuralUnits*2);
      dotTempValue = dotMultiply();
      tempAngle = acos(dotTempValue);
      if(tempAngle<0.21) //if difference less than 10 degrees between vectors
      {
      	match = 1;
      	break; //save cycles break out
      }
    }
    if(match == 0)
    {//no match found - create a new local view cell
    	addAssociation(nextEmptyCell);
    	nextEmptyCell++;
    	nxtDisplayStringAt(70, 10, "New");
      //nxtDisplayCenteredTextLine(6, "cell created");
      PlaySound(soundFastUpwardTones);
      while(bSoundActive) {}
    }
    else if(match == 1)
    {
    	injectEnergy(stepSize, poseAssoc[z].xCell, poseAssoc[z].yCell, poseAssoc[z].thetaCell);
    	//nxtDisplayStringAt(64,30,"x: %2d",poseAssoc[z].xCell);
	    //nxtDisplayStringAt(64,20,"y: %2d",poseAssoc[z].yCell);
	   // nxtDisplayStringAt(64,10,"T: %1d",poseAssoc[z].thetaCell);
    	//nxtDisplayCenteredTextLine(6, "Energy Injected");
      PlaySound(soundBeepBeep);
      while(bSoundActive) {}
    }
  }
}



//----Logs data - for testing only----//
void datalogging()
{
	AddToDatalog(1,maxActivatedCell.x);
  AddToDatalog(2,maxActivatedCell.y);
  AddToDatalog(3,maxActivatedCell.theta);
  AddToDatalog(4,numActive);
}

void datalogging2()
{
	int data;
	for(data = 0; data<numOfExperiences; data++)
	{
		int d1 = (int) Map.experienceMap[data].mapPose.x;
		int d2 = (int) Map.experienceMap[data].mapPose.y;
		int d3 = (int) Map.experienceMap[data].mapPose.z;

	  AddToDatalog(1,d1);
    AddToDatalog(2,d2);
    AddToDatalog(3,d3);
  }
  AddToDatalog(4,0);
}

void datalogging4()
{
	int data;
	for(data = 0; data<=20; data++)
	{
		int d1 = (int) Map.experienceMap[data].mapPose.x;
		int d2 = (int) Map.experienceMap[data].mapPose.y;
		int d3 = (int) Map.experienceMap[data].mapPose.z;

	  AddToDatalog(1,d1);
    AddToDatalog(2,d2);
    AddToDatalog(3,d3);
  }
  AddToDatalog(4,0);
   AddToDatalog(4,0);
    AddToDatalog(4,0);
}
void datalogging5()
{
	int data;
	for(data = 0; data<=20; data++)
	{
		int d1 = (int) Map.experienceMap[data].odoPose.x;
		int d2 = (int) Map.experienceMap[data].odoPose.y;
		int d3 = (int) Map.experienceMap[data].odoPose.z;

	  AddToDatalog(1,d1);
    AddToDatalog(2,d2);
    AddToDatalog(3,d3);
  }
    AddToDatalog(4,0);
    AddToDatalog(4,0);
    AddToDatalog(4,0);
}


void datalogging3()
{
	int data;
	for(data = 0; data<numOfExperiences; data++)
	{
		int d1 = (int) Map.experienceMap[data].outLinks[0];
		int d2 = (int) Map.experienceMap[data].outLinks[1];
		int d3 = (int) Map.experienceMap[data].outLinks[2];
		int d4 = (int) Map.experienceMap[data].outLinks[3];
		int d5 = (int) Map.experienceMap[data].outLinks[4];

		int d6 = (int) Map.experienceMap[data].inLinks[0];
		int d7 = (int) Map.experienceMap[data].inLinks[1];
	  int d8 = (int) Map.experienceMap[data].inLinks[2];
    int d9 = (int) Map.experienceMap[data].inLinks[3];
    int d10 = (int) Map.experienceMap[data].inLinks[4];

	  AddToDatalog(5,d1);
    AddToDatalog(5,d2);
    AddToDatalog(5,d3);
    AddToDatalog(5,d4);
    AddToDatalog(5,d5);
    AddToDatalog(6,d6);
    AddToDatalog(6,d7);
    AddToDatalog(6,d8);
    AddToDatalog(6,d9);
    AddToDatalog(6,d10);
  }
}

void datalogging6()
{
	int data;
	for(data = 0; data<numOfExperiences; data++)
	{
		int d1 = (int) links[data].startExperienceID;
		int d2 = (int) links[data].endExperienceID;

	  AddToDatalog(7,d1);
    AddToDatalog(8,d2);
  }
    AddToDatalog(4,0);
    AddToDatalog(4,0);
    AddToDatalog(4,0);
}

void sumPoseStruct()
{
  float tempStruct[10][10];
  memset(tempStruct,0,400);
  float sumActive = 0;
  if(read)
  {
    for(i = 0; i<sizeX; i++)
    {
      for(j=0; j<sizeY; j++)
      {
        for(k=0; k<sizeTheta; k++)
        {
          tempStruct[i][j] += poseActivity2[i].array2D[j][k];
        }
      }
    }
  }
  else
  {
    for(i = 0; i<sizeX; i++)
    {
      for(j=0; j<sizeY; j++)
      {
        for(k=0; k<sizeTheta; k++)
        {
          tempStruct[i][j] += poseActivity1[i].array2D[j][k];
        }
      }
    }
  }
  sumActive = tempStruct[maxActivatedCell.x][maxActivatedCell.y];
  eraseDisplay();
  nxtDrawRect(1,1,62,62);
  nxtDisplayStringAt(64,60,"x: %d",maxActivatedCell.x);
	nxtDisplayStringAt(64,50,"y: %d",maxActivatedCell.y);
	nxtDisplayStringAt(64,40,"T: %d",maxActivatedCell.theta);
  for(i = 0; i<sizeX; i++)
  {
    for(j = 0; j<sizeY; j++)
    {
      char tempPercent = 0;
      tempPercent = (tempStruct[i][j] / sumActive)*100;
      if(tempPercent<=2) {}
      else if(tempPercent>2 && tempPercent<=7)
      {
        drawRect(i,j,2);
      }
      else if(tempPercent>7 && tempPercent<=15)
      {
        drawRect(i,j,15);
      }
      else if(tempPercent>15 && tempPercent<=25)
      {
        drawRect(i,j,25);
      }
      else if(tempPercent>25 && tempPercent<=33)
      {
        drawRect(i,j,33);
      }
      else if(tempPercent>33 && tempPercent<=50)
      {
        drawRect(i,j,50);
      }
      else if(tempPercent>50 && tempPercent<=66)
      {
        drawRect(i,j,66);
      }
      else if(tempPercent>66 && tempPercent<=75)
      {
        drawRect(i,j,75);
      }
      else if(tempPercent>75 && tempPercent<=97)
      {
        drawRect(i,j,85);
      }
      else if(tempPercent>97 && tempPercent<=100)
      {
        drawRect(i,j,100);
      }
    }
  }
}

//                                //
//----Experience Map Functions----//
//                                //

//----Set up required structures----//
void grabData()
{
  memcpy(localTempView, localTemp, 2*numNeuralUnits);
  maxActivatedCellPose.x = maxActivatedCell.x;
  maxActivatedCellPose.y = maxActivatedCell.y;
  maxActivatedCellPose.theta = maxActivatedCell.theta;
}

//sets experience - not sure if i really need this
void setExperience(char id, vector3DE &odo, PoseCellPosition &pose, localViewCell &local)
{
	Map.experienceMap[id].ID = id;
  memcpy(Map.experienceMap[id].odoPose,odo, 12);
  memcpy(Map.experienceMap[id].poseCellsPose, pose, 3);
  memcpy(Map.experienceMap[id].localView, local,2*numNeuralUnits);
}

void createNewExperience(experience &newE)
{
  //going to assume everytime a createNewExperience is called it will affect the Map.currentExperience experience cell
	memset(newE,0,72);
	//int temp[3] = {-1,-1,-1}; //My null symbol
	newE.mapPose.x = -1; //null - not yet set up
	newE.ID = nextID;
	newE.outLinks[0] = -1;
	newE.outLinks[1] = -1;
  newE.outLinks[2] = -1;
  newE.outLinks[3] = -1;
  newE.outLinks[4] = -1;
	newE.inLinks[0] = -1;
	newE.inLinks[1] = -1;
  newE.inLinks[2] = -1;
  newE.inLinks[3] = -1;
  newE.inLinks[4] = -1;
	//memcpy(newE.outLinks,temp,6); //initalise to null
  //memcpy(newE.inLinks,temp,6);
	memcpy(newE.odoPose,encoderData,12);
	memcpy(newE.poseCellsPose,maxActivatedCellPose,3);
	memcpy(newE.localView,localTempView,2*numNeuralUnits);
}

//----Sets Outlinks and Inlinks----//
//adds references to the link between experiences to the experiences involved (refer to experiencelink.java)
void setOutlinks(char linkID, experience startE, experience endE)
{
	char t; //for loop
	for(t = 0; t<numOfLinksPerExperience; t++)
	{
	  if(startE.outLinks[t] == -1)//an empty link
	  {
	  	startE.outLinks[t] = linkID;
	  	break;
	  }
	}
	for(t = 0; t<numOfLinksPerExperience; t++)
	{
		if(endE.inLinks[t] == -1)//an empty link
	  {
	  	endE.inLinks[t] = linkID;
	  	break;
	  }
	}
}

//Due to various information being needed to calculate the link it is necessary to create the temp experience
// 'currentExperience' and insert it into the experience map once a new experience becomes active
// the linkLastToCurrent performs the linking - with the linkExperience calling that and setting up a new temp
// experience
void linkLastToCurrent()
{
  float currentMeanTime = (Map.currentExperienceStartTime + (nPgmTime/1000)) / 2;

  if(Map.lastMatchedExperienceID != -1) //therefore not null
  {
  	//time taken for transistion
  	float transitionTime = currentMeanTime - Map.lastExperienceMeanTime;

  	//Set up pose info and copy data into
    vector3DE currentOdoPose;
    memcpy(currentOdoPose, Map.currentExperience.odoPose,12); // may need to memcpy
    vector3DE lastOdoPose;
    memcpy(lastOdoPose,Map.experienceMap[Map.lastMatchedExperienceID].odoPose,12); //same as above

    //angle to current (angle = atan(y/x))
    float angleToCurrent = getAngleDegrees((currentOdoPose.x - lastOdoPose.x),(currentOdoPose.y - lastOdoPose.y));
    float translationAngle = lastOdoPose.z - angleToCurrent;

    //translation distance (in encoder clicks)
    int translationDistance = getLength((currentOdoPose.x - lastOdoPose.x),(currentOdoPose.y - lastOdoPose.y));

    //relative change in rotation
    float rotation = getRotationDegrees(lastOdoPose.z, currentOdoPose.z);

    //therefore has not been inserted onto experience map yet
    if(Map.currentExperience.mapPose.x == -1) //null statement
    {
      vector3DE lastMapPose;
      vector3DE newMapPose;
      memcpy(lastMapPose, Map.experienceMap[Map.lastMatchedExperienceID].mapPose, 12);

      float calcsAngle = lastMapPose.z + translationAngle;
      newMapPose.x = (lastMapPose.x + cosDegrees(calcsAngle) * translationDistance);
      newMapPose.y = (lastMapPose.y + sinDegrees(calcsAngle) * translationDistance);
      newMapPose.z = (lastMapPose.z + rotation);
      memcpy(Map.currentExperience.mapPose, newMapPose, 12); //set up mapPose for current Experience
      memcpy(Map.experienceMap[Map.currentExperience.ID], Map.currentExperience, 72); //put currentExperience on the map
    }
    char y;
    int linkNumber;
    for(y = 0; y<numOfLinksPerExperience; y++)
    {
      linkNumber = Map.experienceMap[Map.lastMatchedExperienceID].outLinks[y];
    	if(linkNumber != -1)
    	{
    	  if(links[linkNumber].endExperienceID == Map.currentExperience.ID)
    	  {
    	    break; //using linkNumber
    	  }
    	}
    	linkNumber = -1;
    }
    //if no link
    if(linkNumber == -1)
    {
    	//create new link with all data needed
      experienceLink link;
    	link.startExperienceID = Map.lastMatchedExperienceID;
    	link.endExperienceID = Map.currentExperience.ID;
    	link.transitionTime = transitionTime;
    	link.translationAngle = translationAngle;
    	link.translationDistance = translationDistance;
    	link.rotation = rotation;
    	memcpy(links[nextLink],link,12);
    	setOutlinks(nextLink, Map.experienceMap[Map.lastMatchedExperienceID],Map.experienceMap[Map.currentExperience.ID]); //sets the outlinks and inlinks
    	nextLink++; //increment new link
    }
    //else if link existes, update
    else
    {
      experienceLink previous;
      memcpy(previous,links[linkNumber],12);
      previous.transitionTime = (previous.transitionTime + transitionTime) / 2;
      previous.translationAngle = (previous.translationAngle + translationAngle) / 2;
      previous.translationDistance = (previous.translationDistance + translationDistance) / 2;
      previous.rotation = (previous.rotation + rotation) / 2;
      memcpy(links[linkNumber], previous,12);
    }
  }
  //set current as previous experience
  Map.lastMatchedExperienceID = Map.currentExperience.ID;
  Map.lastExperienceMeanTime = currentMeanTime;
}


void linkExperience(experience &cExperience)
{
  linkLastToCurrent();
	memcpy(Map.currentExperience, cExperience, 72); //add experience
  Map.currentExperienceStartTime = (int) (nPgmTime/1000); //in seconds
}

//sets links --------------may need fixing
void setLink(char startID, char endID)
{
  links[nextLink].startExperienceID = startID;
  links[nextLink].endExperienceID = endID;
}

//----Compares arrays - this is due to RobotC unable to do this----//
char compareArray(localViewCell &view1, localViewCell &view2)
{
	int array1[numNeuralUnits], array2[numNeuralUnits], nullArray[numNeuralUnits];
	memset(nullArray, 0, 2*numNeuralUnits);
	memcpy(array1, view1.localArray, 2*numNeuralUnits);
	memcpy(array2, view2.localArray, 2*numNeuralUnits);

	char check = 0;
	for(i = 0; i<numNeuralUnits; i++)
	{
		if(array1[i] != nullArray[i])
		{
		  check = 1; // not a null vector
		  break;
		}
	}

	if(check)
	{
		float dotValue2 = 0;
    for(i = 0; i < numNeuralUnits; i++)
    {
      if(array1[i]>0)
      {
        dotValue2 = dotValue2 + (array1[i] * array2[i]);
      }
    }
    dotValue2 = (float) (dotValue2/10000);

		float tempAngleExp = acos(dotValue2);
    if(tempAngleExp<0.26) //if difference less than 10 degrees between vectors
    {
      return 1;
    }
    return 0;
	}
	else {return 0;}
}

//----Compares two Experiences----//
float compareTo(experience &experience1, experience &experience2)
{
	float result = 0;
	eraseDisplay();
  //first test
	char firstTest = compareArray(experience1.localView,experience2.localView);
	if(!firstTest)
	{
		nxtDisplayStringAt(64,30,"No");
	    nxtDisplayStringAt(64,20,"No");
	     nxtDisplayStringAt(64,10,"No");
	  return 0;
	}
  nxtDisplayStringAt(64,30,"mat");
  wait10Msec(50);
	//2nd test
  PoseCellPosition thisPose;
	PoseCellPosition otherPose;
	memcpy(thisPose, experience1.poseCellsPose, 3);
	memcpy(otherPose, experience2.poseCellsPose, 3);
  char thetaAbsDist = abs(thisPose.theta - otherPose.theta);
  if(thetaAbsDist > maxAssociationRadiusTheta)
  {
  	nxtDisplayStringAt(64,20,"No");
	     nxtDisplayStringAt(64,10,"No");
    return 0;

  }
  nxtDisplayStringAt(64,20,"mat");
  wait10Msec(50);
  //3rd test
  float maxXYDistSquared = 2;//maxAssociationRadiusXY * maxAssociationRadiusXY;
  int xyDistSquared = ((otherPose.x - thisPose.x) * (otherPose.x - thisPose.x)) +
                        ((otherPose.y - thisPose.y) * (otherPose.y - thisPose.y));

  if(xyDistSquared > maxXYDistSquared)
  {
  	 nxtDisplayStringAt(64,10,"No");
    return 0;
  }
  nxtDisplayStringAt(64,10,"mat");
  wait10Msec(50);
  result = (2 - (sqrt(xyDistSquared) / sqrt(2)) -
                  (thetaAbsDist / maxAssociationRadiusTheta)) * 0.5;
                  wait10Msec(200);
  //otherwise is a measure of comparison from 0 to 1 comprised of a 0.5 contribution from theta and xy respectively
  return result;
}

//this compares the current experience to previous experiences returning the closest matching experience
//returning the array id of the closest experience.
char matchExperience(experience &matchE)
{
  float maxScore = 0;
  int closestMatch = -1;
	int q;
  experience trial;

  for(q = 0; q<nextID; q++)
	{
		memcpy(trial, Map.experienceMap[q], 72);
		float score = compareTo(matchE,trial);
		if(score > maxScore)
		{
		  	closestMatch = q;
		  	maxScore = score;
		}
	}
	return (char) closestMatch;
}

//----Corrects the Experience Map----//
//So far have used floats but as all structs use ints i may be able to get away with not using floats at all. Yay to the memory savings
void mapCorrection()
{
	float mapCorrectionXY = 0.5;
	float mapCorrectionTheta = 0.5;

	experience startExperience;
	experience endExperience;
	vector3DE startPose;
	vector3DE endPose;
	experienceLink link;

	char z; //for loop
	for(z = 0; z <(nextID-1); z++)
	{
		memcpy(startExperience,Map.experienceMap[z],72); //copy experience being manipulated into startExperience
		memcpy(startPose, startExperience.mapPose, 12); //copy mapPose being manipulated into startPose
    char y; //for loop
    for(y = 0; y < numOfLinksPerExperience; y++)
    {
      if(startExperience.outLinks[y] != -1)
      {
        memcpy(link,links[startExperience.outLinks[y]],12);
        memcpy(endExperience,Map.experienceMap[link.endExperienceID],72);
        memcpy(endPose, endExperience.mapPose, 12);

        //expected position of the end experience
        float angleToTargetEnd = startPose.z + link.translationAngle;
        float targetEndX = startPose.x + link.translationDistance * cosDegrees(angleToTargetEnd);
        float targetEndY = startPose.y + link.translationDistance * sinDegrees(angleToTargetEnd);

        //expected orientation of the end experience
        float targetEndAngle = startPose.z + link.rotation;

        //Calulate the 'error' between expected and actual position of end experience
        float xError = targetEndX - endPose.x;
        float yError = targetEndY - endPose.y;
        float thetaError = getRotationDegrees(endPose.z,targetEndAngle);

        //calculate the adjustment to be made for start and end poses
        float xAdjustment = xError * mapCorrectionXY;
        float yAdjustment = yError * mapCorrectionXY;
        float thetaAdjustment = thetaError * mapCorrectionTheta;

        //Apply adjustments then copy back over previous experiences
        startPose.x -= xAdjustment;
        startPose.y -= yAdjustment;
        startPose.z = wrappedDegrees360(startPose.z - thetaAdjustment);

        endPose.x += xAdjustment;
        endPose.y += yAdjustment;
        endPose.z = wrappedDegrees360(endPose.z + thetaAdjustment);

        memcpy(startExperience.mapPose, startPose, 12);
        memcpy(Map.experienceMap[z], startExperience, 72);

        memcpy(endExperience.mapPose, endPose, 12);
        memcpy(Map.experienceMap[link.endExperienceID],endExperience,72);
      }
      else {break;} //leave loop faster as there are no more links
    }
  }
}

//----creates the first experience----//
void startUp()
{
	experience startUpExperience;
  createNewExperience(startUpExperience);
  startUpExperience.mapPose.x = 0;
  startUpExperience.mapPose.y = 0;
  startUpExperience.mapPose.z = 0;
  memcpy(Map.currentExperience,startUpExperience,72);
  Map.currentExperienceStartTime = (int) (nPgmTime/1000);
  //this is my addition - i couldn't find in the java code where the first current view was create placed on the experience map
  memcpy(Map.experienceMap[nextID],Map.currentExperience,72);
  Map.lastMatchedExperienceID = 0;
  nextID++;
}

void iterateMap(float stepSize)
{
  experience newExperience;
  createNewExperience(newExperience);
  char closestExperience = matchExperience(newExperience);

  if(closestExperience != -1)
  {
    if(closestExperience != nextID)
    {
    	experience closeExperience;
    	memcpy(closeExperience,Map.experienceMap[closestExperience],72);
    	linkExperience(closeExperience);
    }
  }
  else
  {
    linkExperience(newExperience);
    nextID++;
  }
}

void initaliseMap()
{
	memset(Map,0,3816);
	Map.lastMatchedExperienceID = -1;
	memset(Links,0,660);
  memset(encoderData,0,12);
  memset(maxActivatedCellPose,0,3);
  memset(localTempView,0,2*numNeuralUnits);
}


//            //
//----Tasks----//
//            //
task everything()
{
	nCurrState = stateRun;
  pose3D(changeTheta, 0.5);
	currentDirection += changeTheta;
  setEncoderData(currentDirection);
  checkLocalCell();
	iterate(stepSize);
  //sumPoseStruct();
  changeTheta=0;
  iterateExperience(stepSize);
  mapCorrection();
  nCurrState = stateStop;
}

task wall()
{
	nWallState = stateRun;
	leftSonarValue = SensorValue[leftSonar];
	centreSonarValue = SensorValue[centreSonar];
	rightSonarValue = SensorValue(rightSonar); //obvious
	if(centreSonarValue < 19)
	{
		averageEncoder = (int) ((nMotorEncoder[motorA] + nMotorEncoder[motorB])/2);
		clearEncoders();
		setEncoderData(currentDirection);
		setTemp();
		motor[motorB] = 0;
    motor[motorC] = 0;
    if(nCurrState == stateStop)
	  {
      StartTask(everything);
      ClearTimer(T2);
    }
    else
    {
      while(nCurrState == stateRun) {}
    	StartTask(everything);
    	ClearTimer(T2);
    }
	  if(leftSonarValue > rightSonarValue)
	  {
      nSyncedMotors = synchBC;
  	  nSyncedTurnRatio = -100;
  	  nMotorEncoderTarget[motorB] = 200;
  	  motor[motorB] = -desiredSpeed;
    	while(nMotorRunState[motorB] != runStateIdle)
    	{
    	 // if(nMotorEncoder[motorB] >= 200) {break;}
    	}
    	motor[motorB] = 0;
      nSyncedMotors = synchNone;
      //changeTheta = 90;
      changeTheta = getRotation();

	  }
		else if(leftSonarValue < rightSonarValue)
	  {
	  	nSyncedMotors = synchBC;
    	nSyncedTurnRatio = -100;
  	  nMotorEncoderTarget[motorB] = 200;
  	  motor[motorB] = desiredSpeed;
  	  while(nMotorRunState[motorB] != runStateIdle)
    	{
    	//  if(nMotorEncoder[motorB] >= 200) {break;}
    	}
    	 motor[motorB] = 0;
      nSyncedMotors = synchNone;
	    //changeTheta = -90;
      changeTheta = getRotation();
	  }
		else if(leftSonarValue < 19 && rightSonarValue < 19)
	  {
	  	nSyncedMotors = synchBC;
    	nSyncedTurnRatio = -100;
    	nMotorEncoderTarget[motorB] = 400;
    	motor[motorB] = desiredSpeed;
      while(nMotorRunState[motorB] != runStateIdle)
    	{
    	  //if(nMotorEncoder[motorB] >= 200) {break;}
    	}
    	 motor[motorB] = 0;
      nSyncedMotors = synchNone;
	  	//changeTheta = 180;
      changeTheta = getRotation();
	   }
	  else
	  {
	  	nSyncedMotors = synchBC;
  	  nSyncedTurnRatio = -100;
  	  nMotorEncoderTarget[motorB] = 200;
  	  motor[motorB] = -desiredSpeed;
      while(nMotorRunState[motorB] != runStateIdle)
    	{
    	  //if(nMotorEncoder[motorB] >= 200) {break;}
    	}
    	motor[motorB] = 0;
      nSyncedMotors = synchNone;
      //changeTheta = 90;
      changeTheta = getRotation();
	  }

	}
	else
	{
		if(leftSonarValue < 30)
	  {
		  int distanceError = leftSonarValue-desiredLeft;
	    float angV = ((-kW*(distanceError))/(desiredSpeed)) - (beta0 + beta1*distanceError);
		  if(angV > (desiredSpeed-5))
		  {
		    angV = desiredSpeed-5;
		  }
		  else if(angV <(-desiredSpeed+5))
	    {
	      angV = -desiredSpeed+5;
	    }
	    motor[motorB] = (int) desiredSpeed + angV;
		  motor[motorC] = (int) desiredSpeed - angV;
		  wait1Msec(50); //100
		  motor[motorB] = (int) desiredSpeed - angV;
		  motor[motorC] = (int) desiredSpeed + angV;
		  wait1Msec(25); //50
		  motor[motorB] = (int) desiredSpeed;
		  motor[motorC] = (int) desiredSpeed;
		  averageEncoder = (int) (nMotorEncoder[motorA] + nMotorEncoder[motorB])/2;
		  clearEncoders();
	  	setEncoderData(currentDirection);
		  setTemp();
		}
		else
		{
			motor[motorB] = 0;
	  	motor[motorC] = 0;
	  	averageEncoder = (int) ((nMotorEncoder[motorA] + nMotorEncoder[motorB])/2)+200;
      clearEncoders();
		  setEncoderData(currentDirection);
	  	nSyncedMotors = synchBC;
	  	nSyncedTurnRatio = 100;
	  	nMotorEncoderTarget[motorB] = 200;
	  	motor[motorB] = desiredSpeed;
	  	while(nMotorRunState[motorB] != runStateIdle) {};
  	  setTemp();
	  	if(nCurrState == stateStop)
	    {
        StartTask(everything);
        ClearTimer(T2);
       }
      else
       {
        while(nCurrState == stateRun) {}
    	  StartTask(everything);
    	  ClearTimer(T2);
      }
	  	nSyncedTurnRatio = -100;
  	  nMotorEncoderTarget[motorB] = 200;
  	  motor[motorB] = -desiredSpeed;
    	while(nMotorRunState[motorB] != runStateIdle)
    	{
    	 // if(nMotorEncoder[motorB] >= 200) {break;}
    	}
     // changeTheta = 90;
    	changeTheta = getRotation();
	  	nSyncedTurnRatio = 100;
	  	leftSonarValue = SensorValue[leftSonar];
	    while(leftSonarValue > 30)
	    {
	  	  motor[motorB] = desiredSpeed;
	  	  leftSonarValue = SensorValue[leftSonar];
	    }
	    motor[motorB] = 0;
	  	nSyncedMotors = synchNone;
	  	motor[motorB] = (int) desiredSpeed;
		  motor[motorC] = (int) desiredSpeed;
		}
	  if(time100[T2] >= 35 && nCurrState == stateStop)
  	{
  		//StopTask(wall);

  		StartTask(everything);
  		//clearEncoders();
  	  ClearTimer(T2);
  	}
	}
	nWallState = stateStop;
}

task main ()
{
	nxtDisplayCenteredTextLine(3, "Roaming-11");
	nxtDisplayCenteredTextLine(5, "This is a test");
	initialisePose(); //set up
	initaliseMap();
	wait10Msec(100);
	setTemp();  //get local view
  checkLocalCell(); //create first association
  startUp();
	iterate(stepSize); //run excitation etc
	currentDirection = 0; //set initial
  currentTheta = 0;
  iterateExperience(stepSize);
	mapCorrection();
  //sumPoseStruct();
	wait10Msec(50);
  ClearTimer(T1);
  ClearTimer(T2);
  nSyncedMotors = synchNone;
  motor[motorB] = desiredSpeed;
  motor[motorC] = desiredSpeed;
  nCurrState = stateStop;
  nWallState = stateStop;
	while(nextID<=20)
	{
		alive(); //stop NXT from sleeping

    if(time1[T1] >= 490 && nWallState == stateStop)
  	{
  	  StartTask(wall);
  		ClearTimer(T1);
  	}
  }
  iterateExperience(stepSize);
  //Problems
  /*
    MapPose isn't working right, have fixed checkLocalCell and changed the match angle to a smaller value
    have also added the check angle to the compareArray for experiences, need to fix the inlinks - currently saying the inlink is the cell number is inlinks is stored in
    i.e. exp 1 has 1 in the inLinks should be 0



  */
  //
  datalogging4(); //mapPose
  datalogging5(); //odoPose
  datalogging3(); //outlinks/inlinks
  datalogging6(); //links startExperienceID and endExperienceID
  SaveNxtDatalog();
  PlaySound(soundException);
  while(bSoundActive){}
}

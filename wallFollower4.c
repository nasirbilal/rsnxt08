#pragma config(Sensor, S1,     leftSonar,           sensorSONAR)
#pragma config(Sensor, S2,     centreSonar,         sensorSONAR)
#pragma config(Sensor, S3,     rightSonar,          sensorSONAR)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int desiredLeft = 15;
int desiredSpeed = 25;
int centreSonarValue = 0;
int leftSonarValue=0;

float k = 40;
float alpha = 0.5;
float beta1 = k/(desiredSpeed);
float beta0 = alpha * beta1;

void doLeftTurn()
{
    nSyncedMotors = synchBC;
  	nSyncedTurnRatio = -100;
  	nMotorEncoderTarget[motorB] = 190;
  	motor[motorB] = -desiredSpeed;
  	while(nMotorRunState[motorB] != runStateIdle) {}
    nSyncedMotors = synchNone;
}

void doRightTurn()
{
    nSyncedMotors = synchBC;
  	nSyncedTurnRatio = -100;
  	nMotorEncoderTarget[motorB] = 200;
  	motor[motorB] = desiredSpeed;
  	while(nMotorRunState[motorB] != runStateIdle) {}
    nSyncedMotors = synchNone;
}

void doRightTurn2()
{
    nSyncedMotors = synchBC;
  	nSyncedTurnRatio = -100;
  	leftSonarValue = SensorValue[centreSonar];
  	while(abs(leftSonarValue - centreSonarValue) > 6)
  	{
  	  motor[motorB] = desiredSpeed;
  	  leftSonarValue = SensorValue[leftSonar];
  	}
    nSyncedMotors = synchNone;
}


void wallFollower()
{
	leftSonarValue = SensorValue[leftSonar];
	if(leftSonarValue < 30)
  {
	  int distanceError = leftSonarValue-desiredLeft;
    float angV = ((-k*(distanceError))/(desiredSpeed)) - (beta0 + beta1*distanceError);
	  if(angV > (desiredSpeed-5))
	  {
	    angV = desiredSpeed-5;
	  }
	  else if(angV <(-desiredSpeed+5))
    {
      angV = -desiredSpeed+5;
    }
    motor[motorB] = (int) desiredSpeed + angV;
	  motor[motorC] = (int) desiredSpeed - angV;
	  wait1Msec(50); //100
	  motor[motorB] = (int) desiredSpeed - angV;
	  motor[motorC] = (int) desiredSpeed + angV;
	  wait1Msec(25); //50
	  motor[motorB] = (int) desiredSpeed;
	  motor[motorC] = (int) desiredSpeed;
	}
	else
	{
		motor[motorB] = 0;
  	motor[motorC] = 0;
  	nSyncedMotors = synchBC;
  	nSyncedTurnRatio = 100;
  	nMotorEncoderTarget[motorB] = 200;
  	motor[motorB] = desiredSpeed;
  	while(nMotorRunState[motorB] != runStateIdle) {};
  	doLeftTurn();
  	nSyncedMotors = synchBC;
  	nSyncedTurnRatio = 100;
  	leftSonarValue = SensorValue[leftSonar];
    while(leftSonarValue > 30)
    {
  	  motor[motorB] = desiredSpeed;
  	  leftSonarValue = SensorValue[leftSonar];
    }
    motor[motorB] = 0;
  	nSyncedMotors = synchNone;
  	motor[motorB] = (int) desiredSpeed;
	  motor[motorC] = (int) desiredSpeed;
	}
}

task main()
{
  nSyncedMotors = synchNone;
  nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;
  nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;
  motor[motorB] = desiredSpeed;
  motor[motorC] = desiredSpeed;
  ClearTimer(T1);
  while(1)
  {
  	centreSonarValue = SensorValue[centreSonar];
  	if(time100[T1] >= 5)
  	{
  	  wallFollower();
  		ClearTimer(T1);
  	}
  	if(centreSonarValue < 19)
  	{
  		doRightTurn();
  		motor[motorB] = desiredSpeed;
  	  motor[motorC] = desiredSpeed;
  	  ClearTimer(T1);
  	}
  }


}
